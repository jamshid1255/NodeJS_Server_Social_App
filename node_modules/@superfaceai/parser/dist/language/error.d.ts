import { CharIndexSpan, LocationSpan, Source } from '../common/source';
import { RuleResultNoMatch } from './syntax/rule';
export declare const enum SyntaxErrorCategory {
    /** Lexer token error */
    LEXER = "Lexer",
    /** Parser rule error */
    PARSER = "Parser",
    /** Script syntax error */
    SCRIPT_SYNTAX = "Script syntax",
    /** Script forbidden construct error */
    SCRIPT_VALIDATION = "Script validation"
}
export declare type ProtoError = {
    /** Relative span of this error with respect to the token it is attached to. */
    readonly relativeSpan: CharIndexSpan;
    readonly detail?: string;
    readonly category: SyntaxErrorCategory;
    readonly hints: string[];
};
export declare class SyntaxError {
    /** Input source that is being parsed. */
    readonly source: Source;
    /** Location of the error. */
    readonly location: LocationSpan;
    /** Category of this error. */
    readonly category: SyntaxErrorCategory;
    /** Additional message attached to the error. */
    readonly detail: string;
    readonly hints: string[];
    constructor(
    /** Input source that is being parsed. */
    source: Source, 
    /** Location of the error. */
    location: LocationSpan, 
    /** Category of this error. */
    category: SyntaxErrorCategory, detail?: string, 
    /** Optional hints that are emitted to help with the resolution. */
    hints?: string[]);
    static fromSyntaxRuleNoMatch(source: Source, result: RuleResultNoMatch): SyntaxError;
    formatVisualization(): string;
    formatHints(): string;
    format(): string;
    get message(): string;
}

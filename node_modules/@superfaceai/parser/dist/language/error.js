"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyntaxError = void 0;
var token_1 = require("./lexer/token");
/**
 * Computes span and the initial line offset of a (up to) 3-line block that encompasses
 * the token at `innerLocation`.
 */
function computeVisualizeBlockSpan(body, innerLocation) {
    // Find start of the block slice, which is one line before the inner line, or from SOF
    var innerLineStart = innerLocation.start.charIndex - (innerLocation.start.column - 1);
    // Line offset is the offset between the innerLine index and the block start line index
    var lineOffset = 0;
    // This finds the last newline before the innerLine newline or -1
    var start = 0;
    if (innerLineStart !== 0) {
        start = body.slice(0, innerLineStart - 1).lastIndexOf('\n') + 1;
        lineOffset = -1;
    }
    // Find end of the vis block slice, which is one line after the inner line, or until EOF
    var end = body.length;
    var innerLineEnd = body.indexOf('\n', innerLocation.end.charIndex);
    if (innerLineEnd !== -1) {
        var nextLineEnd = body.indexOf('\n', innerLineEnd + 1);
        if (nextLineEnd !== -1) {
            end = nextLineEnd;
        }
    }
    return { start: start, end: end, lineOffset: lineOffset };
}
/**
 * Formats line prefix used in block visualization.
 *
 * Example: ` 13 | ` with `padSize = 3` and `lineNumber = 13`.
 */
function formatLinePrefix(padSize, lineNumber) {
    var value = '';
    if (lineNumber !== undefined) {
        value = lineNumber.toString();
    }
    return "".concat(value.padEnd(padSize !== null && padSize !== void 0 ? padSize : 4, ' '), " | ");
}
/**
 * Render error block visualization.
 *
 * Example:
```
 1 | # line before
 2 | 0bA # line with the error
   | ^^^ # error visualization
 3 | # line after
```
 */
function renderErrorVisualization(lines, errorLocation, prefixWidth, firstLineIndex, startPosition) {
    var e_1, _a;
    var output = '';
    var position = startPosition;
    var currentLine = firstLineIndex;
    try {
        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            output += formatLinePrefix(prefixWidth, currentLine);
            output += line + '\n';
            // Check if this line intersects with the error span
            if (position <= errorLocation.end.charIndex &&
                position + line.length >= errorLocation.start.charIndex) {
                output += formatLinePrefix(prefixWidth);
                // Iterate over the characters of the current line
                // If the character is part of the error span, add ^ underneath
                // If it isn't either add a space or, if the character is tab, add a tab
                for (var i = 0; i < line.length; i += 1) {
                    if (i >= errorLocation.start.charIndex - position &&
                        i < errorLocation.end.charIndex - position) {
                        output += '^';
                    }
                    else {
                        if (line.charAt(i) === '\t') {
                            output += '\t';
                        }
                        else {
                            output += ' ';
                        }
                    }
                }
                output += '\n';
            }
            position += line.length;
            currentLine += 1;
            // For newline
            position += 1;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return output;
}
/**
 * Generates and renders error block visualization given the span, location and source.
 */
function generateErrorVisualization(source, location) {
    var visBlock = computeVisualizeBlockSpan(source.body, location);
    // Location within the body plus the offset of the Source metadata.
    var sourceLocation = source.applyLocationOffset(location);
    // Slice of the source that encompasses the token and is
    // delimited by newlines or file boundaries
    var sourceTextSlice = source.body.slice(visBlock.start, visBlock.end);
    var sourceTextLines = sourceTextSlice.split('\n');
    var maxLineNumberLog = Math.log10(sourceLocation.start.line + sourceTextLines.length) + 1;
    // Generate visualization only if the error span is not empty
    var visualization = '';
    if (location.start.charIndex < location.end.charIndex) {
        visualization = renderErrorVisualization(sourceTextLines, location, maxLineNumberLog, sourceLocation.start.line + visBlock.lineOffset, visBlock.start);
    }
    return {
        visualization: visualization,
        maxLineNumberLog: maxLineNumberLog,
        sourceLocation: sourceLocation,
    };
}
function errorCategoryStrings(category) {
    var result = {
        categoryDetail: undefined,
        categoryHints: [],
    };
    switch (category) {
        case "Script syntax" /* SCRIPT_SYNTAX */:
        case "Script validation" /* SCRIPT_VALIDATION */:
            result.categoryDetail = 'Error in script syntax';
            result.categoryHints.push('This was parsed in script context, it might be an error in comlink syntax instead');
            break;
    }
    return result;
}
var SyntaxError = /** @class */ (function () {
    function SyntaxError(
    /** Input source that is being parsed. */
    source, 
    /** Location of the error. */
    location, 
    /** Category of this error. */
    category, detail, 
    /** Optional hints that are emitted to help with the resolution. */
    hints) {
        var _a;
        this.source = source;
        this.location = location;
        this.category = category;
        var _b = errorCategoryStrings(this.category), categoryDetail = _b.categoryDetail, categoryHints = _b.categoryHints;
        this.detail = detail !== null && detail !== void 0 ? detail : 'Invalid or unexpected token';
        if (categoryDetail !== undefined) {
            this.detail = "".concat(categoryDetail, ": ").concat(this.detail);
        }
        this.hints = hints !== null && hints !== void 0 ? hints : [];
        (_a = this.hints).push.apply(_a, __spreadArray([], __read(categoryHints), false));
    }
    SyntaxError.fromSyntaxRuleNoMatch = function (source, result) {
        var _a, _b;
        var actual = '<NONE>';
        if (result.attempts.token !== undefined) {
            var fmt = (0, token_1.formatTokenData)(result.attempts.token.data);
            switch (result.attempts.token.data.kind) {
                case 1 /* SEPARATOR */:
                case 2 /* OPERATOR */:
                case 3 /* LITERAL */:
                case 5 /* IDENTIFIER */:
                    actual = '`' + fmt.data + '`';
                    break;
                case 4 /* STRING */:
                    actual = '"' + fmt.data + '"';
                    break;
                case 0 /* UNKNOWN */:
                    return result.attempts.token.data.error;
                default:
                    actual = fmt.kind;
                    break;
            }
        }
        // The default location is invalid on purpose
        var location = (_b = (_a = result.attempts.token) === null || _a === void 0 ? void 0 : _a.location) !== null && _b !== void 0 ? _b : {
            start: { line: 0, column: 0, charIndex: 0 },
            end: { line: 0, column: 0, charIndex: 0 },
        };
        var expectedFilterSet = new Set();
        var expected = result.attempts.rules
            .map(function (r) { return r.toString(); })
            .filter(function (r) {
            if (expectedFilterSet.has(r)) {
                return false;
            }
            expectedFilterSet.add(r);
            return true;
        })
            .join(' or ');
        return new SyntaxError(source, location, "Parser" /* PARSER */, "Expected ".concat(expected, " but found ").concat(actual));
    };
    SyntaxError.prototype.formatVisualization = function () {
        // Generate the lines
        var _a = generateErrorVisualization(this.source, this.location), visualization = _a.visualization, maxLineNumberLog = _a.maxLineNumberLog, sourceLocation = _a.sourceLocation;
        var locationLinePrefix = ' '.repeat(maxLineNumberLog) + '--> ';
        var locationLine = "".concat(locationLinePrefix).concat(this.source.fileName, ":").concat(sourceLocation.start.line, ":").concat(sourceLocation.start.column);
        return "".concat(locationLine, "\n").concat(visualization);
    };
    SyntaxError.prototype.formatHints = function () {
        function isString(i) {
            return i !== undefined;
        }
        var filtered = this.hints.filter(isString);
        if (filtered.length === 0) {
            return '';
        }
        return filtered.map(function (h) { return "Hint: ".concat(h); }).join('\n');
    };
    SyntaxError.prototype.format = function () {
        return "SyntaxError: ".concat(this.detail, "\n").concat(this.formatVisualization(), "\n").concat(this.formatHints());
    };
    Object.defineProperty(SyntaxError.prototype, "message", {
        get: function () {
            // TODO
            return this.detail;
        },
        enumerable: false,
        configurable: true
    });
    return SyntaxError;
}());
exports.SyntaxError = SyntaxError;
//# sourceMappingURL=error.js.map
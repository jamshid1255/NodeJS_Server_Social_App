"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyntaxRuleDebugLog = exports.SyntaxRuleNever = exports.SyntaxRuleMutable = exports.SyntaxRuleAndThen = exports.SyntaxRuleMap = exports.SyntaxRuleLookahead = exports.SyntaxRuleOptional = exports.SyntaxRuleRepeat = exports.SyntaxRuleFollowedBy = exports.SyntaxRuleOr = exports.SyntaxRuleJessie = exports.SyntaxRuleNewline = exports.SyntaxRuleString = exports.SyntaxRuleLiteral = exports.SyntaxRuleIdentifier = exports.SyntaxRuleOperator = exports.SyntaxRuleSeparator = exports.SyntaxRule = exports.MatchAttempts = void 0;
var token_1 = require("../lexer/token");
var MatchAttempts = /** @class */ (function () {
    function MatchAttempts(
    /** Token at which the rules failed */
    token, 
    /** Rules which failed at the token */
    rules) {
        this.token = token;
        this.rules = rules;
    }
    MatchAttempts.merge = function (first, second) {
        if (first === undefined) {
            return second;
        }
        return first.merge(second);
    };
    /** Merges two rule attempts according to the furthest token heuristic. */
    MatchAttempts.prototype.merge = function (other) {
        if (other === undefined) {
            return this;
        }
        // resolve undefined
        if (this.token === undefined && other.token === undefined) {
            return new MatchAttempts(this.token, __spreadArray(__spreadArray([], __read(this.rules), false), __read(other.rules), false));
        }
        // undefined is treated as greater than defined
        if (this.token === undefined) {
            return this;
        }
        else if (other.token === undefined) {
            return other;
        }
        // if the tokens are of UNKNOWN variant then we compare their error spans instead
        var thisLocation = this.token.data.kind === 0 /* UNKNOWN */
            ? this.token.data.error.location
            : this.token.location;
        var otherLocation = other.token.data.kind === 0 /* UNKNOWN */
            ? other.token.data.error.location
            : other.token.location;
        if (thisLocation.start.charIndex === otherLocation.start.charIndex) {
            return new MatchAttempts(this.token, __spreadArray(__spreadArray([], __read(this.rules), false), __read(other.rules), false));
        }
        if (thisLocation.start.charIndex > otherLocation.start.charIndex) {
            return this;
        }
        else {
            return other;
        }
    };
    return MatchAttempts;
}());
exports.MatchAttempts = MatchAttempts;
var SyntaxRule = /** @class */ (function () {
    function SyntaxRule() {
    }
    SyntaxRule.prototype.simpleTryMatchBoilerplate = function (tokens, predicate, context) {
        var save = tokens.save();
        var next = tokens.next(context);
        if (next.done === false) {
            var token = next.value;
            var match = predicate(token);
            if (match !== undefined) {
                return {
                    kind: 'match',
                    match: match,
                };
            }
        }
        tokens.rollback(save);
        return {
            kind: 'nomatch',
            attempts: new MatchAttempts(next.value, [this]),
        };
    };
    SyntaxRule.prototype.toString = function () {
        return this[Symbol.toStringTag]();
    };
    // Factory methods for basic rules
    SyntaxRule.separator = function (separator) {
        return new SyntaxRuleSeparator(separator);
    };
    SyntaxRule.operator = function (operator) {
        return new SyntaxRuleOperator(operator);
    };
    SyntaxRule.identifier = function (identifier) {
        return new SyntaxRuleIdentifier(identifier);
    };
    SyntaxRule.literal = function () {
        return new SyntaxRuleLiteral();
    };
    SyntaxRule.string = function () {
        return new SyntaxRuleString();
    };
    SyntaxRule.newline = function () {
        return new SyntaxRuleNewline();
    };
    SyntaxRule.jessie = function (terminatingChars) {
        return new SyntaxRuleJessie(terminatingChars);
    };
    // Combinators
    SyntaxRule.or = function () {
        var rules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rules[_i] = arguments[_i];
        }
        return new (SyntaxRuleOr.bind.apply(SyntaxRuleOr, __spreadArray([void 0], __read(rules), false)))();
    };
    SyntaxRule.followedBy = function () {
        var rules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rules[_i] = arguments[_i];
        }
        return new (SyntaxRuleFollowedBy.bind.apply(SyntaxRuleFollowedBy, __spreadArray([void 0], __read(rules), false)))();
    };
    SyntaxRule.prototype.or = function (rule) {
        return new SyntaxRuleOr(this, rule);
    };
    SyntaxRule.prototype.followedBy = function (rule) {
        return new SyntaxRuleFollowedBy(this, rule);
    };
    // Cannot return `SyntaxRuleMap` because that would confuse TS into thinking `SyntaxRule` is contravariant over `T`
    SyntaxRule.prototype.map = function (mapper) {
        return new SyntaxRuleMap(this, mapper);
    };
    SyntaxRule.prototype.andThen = function (then, description) {
        return new SyntaxRuleAndThen(this, then, description);
    };
    /** Ensures that `this` is followed by `rule` without consuming any tokens after `this`. */
    SyntaxRule.prototype.lookahead = function (rule) {
        return new SyntaxRuleFollowedBy(this, new SyntaxRuleLookahead(rule)).map(function (_a) {
            var _b = __read(_a, 2), me = _b[0], _lookahead = _b[1];
            return me;
        });
    };
    /** Skips `rule` following `this` without affecting the returned type. */
    SyntaxRule.prototype.skip = function (rule) {
        return new SyntaxRuleFollowedBy(this, rule).map(function (_a) {
            var _b = __read(_a, 2), me = _b[0], _skipped = _b[1];
            return me;
        });
    };
    /** Forgets `this` and expects `rule` to follow. */
    SyntaxRule.prototype.forgetFollowedBy = function (rule) {
        return new SyntaxRuleFollowedBy(this, rule).map(function (_a) {
            var _b = __read(_a, 2), _me = _b[0], newres = _b[1];
            return newres;
        });
    };
    SyntaxRule.repeat = function (rule) {
        return new SyntaxRuleRepeat(rule);
    };
    SyntaxRule.optional = function (rule) {
        return new SyntaxRuleOptional(rule);
    };
    SyntaxRule.optionalRepeat = function (rule) {
        return new SyntaxRuleOptional(new SyntaxRuleRepeat(rule));
    };
    /**
     * Returns `rule` that cannot be preceded by a newline.
     * Example usage: `SyntaxRule.identifier('slot').followedBy(SyntaxRule.sameLine(SyntaxRule.string()))`
     */
    SyntaxRule.sameLine = function (rule) {
        return new SyntaxRuleFollowedBy(
        // This behavior is special, because `SyntaxRuleNewline` changes the token filter in the `tokens` stream
        // otherwise this construct would not be of much use
        new SyntaxRuleLookahead(SyntaxRule.newline(), true), rule).map(function (_a) {
            var _b = __read(_a, 2), _ = _b[0], r = _b[1];
            return r;
        });
    };
    SyntaxRule.prototype.debug = function () {
        return new SyntaxRuleDebugLog(this);
    };
    return SyntaxRule;
}());
exports.SyntaxRule = SyntaxRule;
// BASIC //
var SyntaxRuleSeparator = /** @class */ (function (_super) {
    __extends(SyntaxRuleSeparator, _super);
    function SyntaxRuleSeparator(separator) {
        var _this = _super.call(this) || this;
        _this.separator = separator;
        return _this;
    }
    SyntaxRuleSeparator.prototype.tryMatch = function (tokens) {
        var _this = this;
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 1 /* SEPARATOR */) {
                if (_this.separator === undefined ||
                    token.data.separator === _this.separator) {
                    return {
                        data: token.data,
                        location: token.location,
                    };
                }
            }
            return undefined;
        });
    };
    SyntaxRuleSeparator.prototype[Symbol.toStringTag] = function () {
        if (this.separator !== undefined) {
            return '`' + this.separator + '`';
        }
        return (0, token_1.formatTokenKind)(1 /* SEPARATOR */);
    };
    return SyntaxRuleSeparator;
}(SyntaxRule));
exports.SyntaxRuleSeparator = SyntaxRuleSeparator;
var SyntaxRuleOperator = /** @class */ (function (_super) {
    __extends(SyntaxRuleOperator, _super);
    function SyntaxRuleOperator(operator) {
        var _this = _super.call(this) || this;
        _this.operator = operator;
        return _this;
    }
    SyntaxRuleOperator.prototype.tryMatch = function (tokens) {
        var _this = this;
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 2 /* OPERATOR */) {
                if (_this.operator === undefined ||
                    token.data.operator === _this.operator) {
                    return {
                        data: token.data,
                        location: token.location,
                    };
                }
            }
            return undefined;
        });
    };
    SyntaxRuleOperator.prototype[Symbol.toStringTag] = function () {
        if (this.operator !== undefined) {
            return '`' + this.operator + '`';
        }
        return (0, token_1.formatTokenKind)(2 /* OPERATOR */);
    };
    return SyntaxRuleOperator;
}(SyntaxRule));
exports.SyntaxRuleOperator = SyntaxRuleOperator;
var SyntaxRuleIdentifier = /** @class */ (function (_super) {
    __extends(SyntaxRuleIdentifier, _super);
    function SyntaxRuleIdentifier(identifier) {
        var _this = _super.call(this) || this;
        _this.identifier = identifier;
        return _this;
    }
    SyntaxRuleIdentifier.prototype.tryMatch = function (tokens) {
        var _this = this;
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 5 /* IDENTIFIER */) {
                if (_this.identifier === undefined ||
                    token.data.identifier === _this.identifier) {
                    return {
                        data: token.data,
                        location: token.location,
                    };
                }
            }
            return undefined;
        });
    };
    SyntaxRuleIdentifier.prototype[Symbol.toStringTag] = function () {
        if (this.identifier !== undefined) {
            return '`' + this.identifier + '`';
        }
        return (0, token_1.formatTokenKind)(5 /* IDENTIFIER */);
    };
    return SyntaxRuleIdentifier;
}(SyntaxRule));
exports.SyntaxRuleIdentifier = SyntaxRuleIdentifier;
var SyntaxRuleLiteral = /** @class */ (function (_super) {
    __extends(SyntaxRuleLiteral, _super);
    function SyntaxRuleLiteral() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SyntaxRuleLiteral.prototype.tryMatch = function (tokens) {
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 3 /* LITERAL */) {
                return {
                    data: token.data,
                    location: token.location,
                };
            }
            return undefined;
        });
    };
    SyntaxRuleLiteral.prototype[Symbol.toStringTag] = function () {
        return (0, token_1.formatTokenKind)(3 /* LITERAL */);
    };
    return SyntaxRuleLiteral;
}(SyntaxRule));
exports.SyntaxRuleLiteral = SyntaxRuleLiteral;
var SyntaxRuleString = /** @class */ (function (_super) {
    __extends(SyntaxRuleString, _super);
    function SyntaxRuleString() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SyntaxRuleString.prototype.tryMatch = function (tokens) {
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 4 /* STRING */) {
                return {
                    data: token.data,
                    location: token.location,
                };
            }
            return undefined;
        });
    };
    SyntaxRuleString.prototype[Symbol.toStringTag] = function () {
        return (0, token_1.formatTokenKind)(4 /* STRING */);
    };
    return SyntaxRuleString;
}(SyntaxRule));
exports.SyntaxRuleString = SyntaxRuleString;
// SPECIFIC //
var SyntaxRuleNewline = /** @class */ (function (_super) {
    __extends(SyntaxRuleNewline, _super);
    function SyntaxRuleNewline() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SyntaxRuleNewline.prototype.tryMatch = function (tokens) {
        var originalFilter = tokens.tokenKindFilter[7 /* NEWLINE */];
        tokens.tokenKindFilter[7 /* NEWLINE */] = false;
        var result = this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 7 /* NEWLINE */) {
                return {
                    data: token.data,
                    location: token.location,
                };
            }
            return undefined;
        });
        tokens.tokenKindFilter[7 /* NEWLINE */] = originalFilter;
        return result;
    };
    SyntaxRuleNewline.prototype[Symbol.toStringTag] = function () {
        return (0, token_1.formatTokenKind)(7 /* NEWLINE */);
    };
    return SyntaxRuleNewline;
}(SyntaxRule));
exports.SyntaxRuleNewline = SyntaxRuleNewline;
var SyntaxRuleJessie = /** @class */ (function (_super) {
    __extends(SyntaxRuleJessie, _super);
    function SyntaxRuleJessie(terminationTokens) {
        var _this = _super.call(this) || this;
        _this.terminationTokens = terminationTokens;
        return _this;
    }
    SyntaxRuleJessie.prototype.tryMatch = function (tokens) {
        return this.simpleTryMatchBoilerplate(tokens, function (token) {
            if (token.data.kind === 8 /* JESSIE_SCRIPT */) {
                return {
                    data: token.data,
                    location: token.location,
                };
            }
            return undefined;
        }, {
            type: 1 /* JESSIE_SCRIPT_EXPRESSION */,
            terminationTokens: this.terminationTokens,
        });
    };
    SyntaxRuleJessie.prototype[Symbol.toStringTag] = function () {
        return (0, token_1.formatTokenKind)(8 /* JESSIE_SCRIPT */);
    };
    return SyntaxRuleJessie;
}(SyntaxRule));
exports.SyntaxRuleJessie = SyntaxRuleJessie;
var SyntaxRuleOr = /** @class */ (function (_super) {
    __extends(SyntaxRuleOr, _super);
    function SyntaxRuleOr() {
        var rules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rules[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this.rules = rules;
        return _this;
    }
    SyntaxRuleOr.prototype.tryMatch = function (tokens) {
        var e_1, _a;
        var attempts = undefined;
        try {
            for (var _b = __values(this.rules), _c = _b.next(); !_c.done; _c = _b.next()) {
                var rule = _c.value;
                // Basic rules automatically restore `tokens` state on `nomatch`
                var match = rule.tryMatch(tokens);
                if (match.kind === 'match') {
                    return {
                        kind: 'match',
                        // typescript fails us with understand here that the type is correct
                        match: match.match,
                        optionalAttempts: MatchAttempts.merge(attempts, match.optionalAttempts),
                    };
                }
                else {
                    attempts = MatchAttempts.merge(attempts, match.attempts);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (attempts === undefined) {
            // `this.rules` is an empty array
            return {
                kind: 'nomatch',
                attempts: new MatchAttempts(tokens.peek().value, [this]),
            };
        }
        else {
            return {
                kind: 'nomatch',
                attempts: attempts,
            };
        }
    };
    SyntaxRuleOr.prototype[Symbol.toStringTag] = function () {
        return this.rules.map(function (r) { return r.toString(); }).join(' or ');
    };
    return SyntaxRuleOr;
}(SyntaxRule));
exports.SyntaxRuleOr = SyntaxRuleOr;
var SyntaxRuleFollowedBy = /** @class */ (function (_super) {
    __extends(SyntaxRuleFollowedBy, _super);
    function SyntaxRuleFollowedBy() {
        var rules = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rules[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this.rules = rules;
        return _this;
    }
    SyntaxRuleFollowedBy.prototype.tryMatch = function (tokens) {
        var e_2, _a;
        var save = tokens.save();
        var optionalAttempts = undefined;
        var matches = [];
        try {
            for (var _b = __values(this.rules), _c = _b.next(); !_c.done; _c = _b.next()) {
                var rule = _c.value;
                var match = rule.tryMatch(tokens);
                if (match.kind === 'nomatch') {
                    tokens.rollback(save);
                    return __assign(__assign({}, match), { attempts: MatchAttempts.merge(optionalAttempts, match.attempts) });
                }
                else {
                    optionalAttempts = MatchAttempts.merge(optionalAttempts, match.optionalAttempts);
                    matches.push(match.match);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return {
            kind: 'match',
            // we force the type here because typescript cannot check it for us
            // the value of `matches` is a collection of matches of all `this.rules` in order - i.e. `F`.
            match: matches,
            optionalAttempts: optionalAttempts,
        };
    };
    SyntaxRuleFollowedBy.prototype[Symbol.toStringTag] = function () {
        return this.rules.map(function (r) { return r.toString(); }).join(' -> ');
    };
    return SyntaxRuleFollowedBy;
}(SyntaxRule));
exports.SyntaxRuleFollowedBy = SyntaxRuleFollowedBy;
/** Matches one or more occurences of `rule`. */
var SyntaxRuleRepeat = /** @class */ (function (_super) {
    __extends(SyntaxRuleRepeat, _super);
    function SyntaxRuleRepeat(rule) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    SyntaxRuleRepeat.prototype.tryMatch = function (tokens) {
        var matches = [];
        var lastMatch;
        var lastResult;
        for (;;) {
            lastResult = this.rule.tryMatch(tokens);
            if (lastResult.kind === 'match') {
                lastMatch = lastResult;
                matches.push(lastMatch.match);
            }
            else {
                break;
            }
        }
        if (matches.length > 0) {
            return {
                kind: 'match',
                match: matches,
                optionalAttempts: lastResult.attempts.merge(lastMatch === null || lastMatch === void 0 ? void 0 : lastMatch.optionalAttempts),
            };
        }
        return lastResult;
    };
    SyntaxRuleRepeat.prototype[Symbol.toStringTag] = function () {
        return 'one or more ' + this.rule.toString();
    };
    return SyntaxRuleRepeat;
}(SyntaxRule));
exports.SyntaxRuleRepeat = SyntaxRuleRepeat;
/** Matches zero or one occurences of `rule`. */
var SyntaxRuleOptional = /** @class */ (function (_super) {
    __extends(SyntaxRuleOptional, _super);
    function SyntaxRuleOptional(rule) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    SyntaxRuleOptional.prototype.tryMatch = function (tokens) {
        var match = this.rule.tryMatch(tokens);
        if (match.kind === 'match') {
            return match;
        }
        return {
            kind: 'match',
            match: undefined,
            optionalAttempts: match.attempts,
        };
    };
    SyntaxRuleOptional.prototype[Symbol.toStringTag] = function () {
        return 'optional ' + this.rule.toString();
    };
    return SyntaxRuleOptional;
}(SyntaxRule));
exports.SyntaxRuleOptional = SyntaxRuleOptional;
// META //
/** Matches rule and then restores `tokens` state. */
var SyntaxRuleLookahead = /** @class */ (function (_super) {
    __extends(SyntaxRuleLookahead, _super);
    function SyntaxRuleLookahead(rule, invert) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        _this.invert = invert !== null && invert !== void 0 ? invert : false;
        return _this;
    }
    SyntaxRuleLookahead.prototype.tryMatch = function (tokens) {
        var save = tokens.save();
        var result = this.rule.tryMatch(tokens);
        tokens.rollback(save);
        // Handle inversion
        if (this.invert) {
            if (result.kind === 'nomatch') {
                return {
                    kind: 'match',
                    match: undefined,
                };
            }
            else {
                return {
                    kind: 'nomatch',
                    attempts: new MatchAttempts(tokens.peek().value, [this]),
                };
            }
        }
        if (result.kind === 'match') {
            return __assign(__assign({}, result), { match: undefined });
        }
        return result;
    };
    SyntaxRuleLookahead.prototype[Symbol.toStringTag] = function () {
        return (this.invert ? 'not ' : '') + this.rule.toString();
    };
    return SyntaxRuleLookahead;
}(SyntaxRule));
exports.SyntaxRuleLookahead = SyntaxRuleLookahead;
// CUSTOM LOGIC //
/** Maps `match` value on success. */
var SyntaxRuleMap = /** @class */ (function (_super) {
    __extends(SyntaxRuleMap, _super);
    function SyntaxRuleMap(rule, mapper) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        _this.mapper = mapper;
        return _this;
    }
    SyntaxRuleMap.prototype.tryMatch = function (tokens) {
        var match = this.rule.tryMatch(tokens);
        if (match.kind === 'match') {
            return __assign(__assign({}, match), { match: this.mapper(match.match) });
        }
        return match;
    };
    SyntaxRuleMap.prototype[Symbol.toStringTag] = function () {
        return this.rule.toString();
    };
    return SyntaxRuleMap;
}(SyntaxRule));
exports.SyntaxRuleMap = SyntaxRuleMap;
var SyntaxRuleAndThen = /** @class */ (function (_super) {
    __extends(SyntaxRuleAndThen, _super);
    function SyntaxRuleAndThen(rule, then, description) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        _this.then = then;
        _this.description = description;
        return _this;
    }
    SyntaxRuleAndThen.prototype.tryMatch = function (tokens) {
        var peek = tokens.peek().value;
        var match = this.rule.tryMatch(tokens);
        if (match.kind === 'match') {
            var then = this.then(match.match);
            if (then.kind == 'match') {
                return {
                    kind: 'match',
                    match: then.value,
                    optionalAttempts: match.optionalAttempts,
                };
            }
            else {
                return {
                    kind: 'nomatch',
                    attempts: new MatchAttempts(peek, [this]).merge(match.optionalAttempts),
                };
            }
        }
        return match;
    };
    SyntaxRuleAndThen.prototype[Symbol.toStringTag] = function () {
        var _a;
        return (_a = this.description) !== null && _a !== void 0 ? _a : this.rule.toString();
    };
    return SyntaxRuleAndThen;
}(SyntaxRule));
exports.SyntaxRuleAndThen = SyntaxRuleAndThen;
// OTHER //
/**
 * Mutable rule.
 *
 * Since the syntax tree node types are recursive, it follows that the rule definitions must be too.
 * However, there is no way to achieve constant recursiveness - e.g. mutability must be used.
 *
 * This rule provides the option to mutate the inner rule after the object has been created
 * to allow for this mutability. However, it should not be used outside the usecase.
 */
var SyntaxRuleMutable = /** @class */ (function (_super) {
    __extends(SyntaxRuleMutable, _super);
    function SyntaxRuleMutable(
    // NOT readonly
    rule) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    SyntaxRuleMutable.prototype.tryMatch = function (tokens) {
        if (this.rule === undefined) {
            throw 'This method should never be called before the mutable rule is initialized. This is an error in syntax rules definition.';
        }
        return this.rule.tryMatch(tokens);
    };
    SyntaxRuleMutable.prototype[Symbol.toStringTag] = function () {
        if (this.rule === undefined) {
            throw 'This method should never be called before the mutable rule is initialized. This is an error in syntax rules definition.';
        }
        return '[Mutable Rule]';
    };
    return SyntaxRuleMutable;
}(SyntaxRule));
exports.SyntaxRuleMutable = SyntaxRuleMutable;
/**
 * Never rules.
 *
 * This rule never matches.
 */
var SyntaxRuleNever = /** @class */ (function (_super) {
    __extends(SyntaxRuleNever, _super);
    function SyntaxRuleNever() {
        return _super.call(this) || this;
    }
    SyntaxRuleNever.prototype.tryMatch = function (tokens) {
        return {
            kind: 'nomatch',
            attempts: new MatchAttempts(tokens.peek().value, [this]),
        };
    };
    SyntaxRuleNever.prototype[Symbol.toStringTag] = function () {
        return '<NEVER>';
    };
    return SyntaxRuleNever;
}(SyntaxRule));
exports.SyntaxRuleNever = SyntaxRuleNever;
var SyntaxRuleDebugLog = /** @class */ (function (_super) {
    __extends(SyntaxRuleDebugLog, _super);
    function SyntaxRuleDebugLog(rule) {
        var _this = _super.call(this) || this;
        _this.rule = rule;
        return _this;
    }
    SyntaxRuleDebugLog.prototype.tryMatch = function (tokens) {
        var nextToken = tokens.peek().value;
        var result;
        try {
            result = this.rule.tryMatch(tokens);
        }
        catch (err) {
            console.debug('\nRule:', this.rule, '\nException:', err, '\nFirst token:', nextToken);
            throw err;
        }
        if (result.kind === 'nomatch') {
            console.debug('\nRule:', this.rule, '\nAttempts:', result.attempts, '\nFirst token:', nextToken);
        }
        else {
            console.debug('\nRule:', this.rule, '\nMatch:', result.match, '\nFirst token:', nextToken);
        }
        return result;
    };
    SyntaxRuleDebugLog.prototype[Symbol.toStringTag] = function () {
        return this.rule.toString();
    };
    return SyntaxRuleDebugLog;
}(SyntaxRule));
exports.SyntaxRuleDebugLog = SyntaxRuleDebugLog;
//# sourceMappingURL=rule.js.map
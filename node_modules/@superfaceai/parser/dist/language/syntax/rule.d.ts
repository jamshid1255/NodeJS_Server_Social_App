import { LocationSpan } from '../../common/source';
import { LexerContext } from '../lexer/context';
import { LexerTokenStream } from '../lexer/lexer';
import { IdentifierTokenData, IdentifierValue, JessieScriptTokenData, LexerToken, LexerTokenData, LiteralTokenData, NewlineTokenData, OperatorTokenData, OperatorValue, SeparatorTokenData, SeparatorValue, StringTokenData, TerminationTokens } from '../lexer/token';
export declare class MatchAttempts {
    /** Token at which the rules failed */
    readonly token: LexerToken | undefined;
    /** Rules which failed at the token */
    readonly rules: readonly SyntaxRule<unknown>[];
    constructor(
    /** Token at which the rules failed */
    token: LexerToken | undefined, 
    /** Rules which failed at the token */
    rules: readonly SyntaxRule<unknown>[]);
    static merge(first: MatchAttempts, second: MatchAttempts | undefined): MatchAttempts;
    static merge(first: MatchAttempts | undefined, second: MatchAttempts): MatchAttempts;
    static merge(first: MatchAttempts | undefined, second: MatchAttempts | undefined): MatchAttempts | undefined;
    /** Merges two rule attempts according to the furthest token heuristic. */
    merge(other: MatchAttempts | undefined): MatchAttempts;
}
export declare type RuleResultMatch<T> = {
    kind: 'match';
    match: T;
    /** Optional and repeat rule propagate failures through this filed to report better errors. */
    optionalAttempts?: MatchAttempts;
};
export declare type RuleResultNoMatch = {
    kind: 'nomatch';
    attempts: MatchAttempts;
};
export declare type RuleResult<T> = RuleResultMatch<T> | RuleResultNoMatch;
export interface LexerTokenMatch<D extends LexerTokenData = LexerTokenData> {
    readonly data: D;
    readonly location: LocationSpan;
}
export declare abstract class SyntaxRule<T> {
    /**
     * Attempts to match rule to tokens.
     *
     * If the rule matches, matched tokens are transformed into a syntax tree node
     * in the `RuleResultMatch` object and consumed from the iterator.
     *
     * If the rule doesn't match `RuleResultNoMatch` is returned and no tokens are
     * consumed (iterator state is restored).
     */
    abstract tryMatch(tokens: LexerTokenStream): RuleResult<T>;
    protected simpleTryMatchBoilerplate(tokens: LexerTokenStream, predicate: (token: LexerToken) => T | undefined, context?: LexerContext): RuleResult<T>;
    toString(): string;
    abstract [Symbol.toStringTag](): string;
    static separator(separator?: SeparatorValue): SyntaxRuleSeparator;
    static operator(operator?: OperatorValue): SyntaxRuleOperator;
    static identifier(identifier?: IdentifierValue): SyntaxRuleIdentifier;
    static literal(): SyntaxRuleLiteral;
    static string(): SyntaxRuleString;
    static newline(): SyntaxRuleNewline;
    static jessie(terminatingChars?: ReadonlyArray<TerminationTokens>): SyntaxRuleJessie;
    static or<R extends SyntaxRule<unknown>[]>(...rules: R): SyntaxRuleOr<PeelTupleSyntaxRule<R>>;
    static followedBy<R extends SyntaxRule<unknown>[]>(...rules: R): SyntaxRuleFollowedBy<PeelTupleSyntaxRule<R>>;
    or<R>(rule: SyntaxRule<R>): SyntaxRuleOr<[T, R]>;
    followedBy<R>(rule: SyntaxRule<R>): SyntaxRuleFollowedBy<[T, R]>;
    map<M>(mapper: (_: T) => M): SyntaxRule<M>;
    andThen<M>(then: (_: T) => AndThenResult<M>, description?: string): SyntaxRule<M>;
    /** Ensures that `this` is followed by `rule` without consuming any tokens after `this`. */
    lookahead<R>(rule: SyntaxRule<R>): SyntaxRule<T>;
    /** Skips `rule` following `this` without affecting the returned type. */
    skip<R>(rule: SyntaxRule<R>): SyntaxRule<T>;
    /** Forgets `this` and expects `rule` to follow. */
    forgetFollowedBy<R>(rule: SyntaxRule<R>): SyntaxRule<R>;
    static repeat<R>(rule: SyntaxRule<R>): SyntaxRuleRepeat<R>;
    static optional<R>(rule: SyntaxRule<R>): SyntaxRuleOptional<R>;
    static optionalRepeat<R>(rule: SyntaxRule<R>): SyntaxRuleOptional<[R, ...R[]]>;
    /**
     * Returns `rule` that cannot be preceded by a newline.
     * Example usage: `SyntaxRule.identifier('slot').followedBy(SyntaxRule.sameLine(SyntaxRule.string()))`
     */
    static sameLine<R>(rule: SyntaxRule<R>): SyntaxRule<R>;
    debug(): SyntaxRule<T>;
}
export declare class SyntaxRuleSeparator extends SyntaxRule<LexerTokenMatch<SeparatorTokenData>> {
    readonly separator?: SeparatorValue | undefined;
    constructor(separator?: SeparatorValue | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<SeparatorTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleOperator extends SyntaxRule<LexerTokenMatch<OperatorTokenData>> {
    readonly operator?: OperatorValue | undefined;
    constructor(operator?: OperatorValue | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<OperatorTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleIdentifier extends SyntaxRule<LexerTokenMatch<IdentifierTokenData>> {
    readonly identifier?: string | undefined;
    constructor(identifier?: string | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<IdentifierTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleLiteral extends SyntaxRule<LexerTokenMatch<LiteralTokenData>> {
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<LiteralTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleString extends SyntaxRule<LexerTokenMatch<StringTokenData>> {
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<StringTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleNewline extends SyntaxRule<LexerTokenMatch<NewlineTokenData>> {
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<NewlineTokenData>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleJessie extends SyntaxRule<LexerTokenMatch<JessieScriptTokenData>> {
    readonly terminationTokens?: readonly TerminationTokens[] | undefined;
    constructor(terminationTokens?: readonly TerminationTokens[] | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<LexerTokenMatch<JessieScriptTokenData>>;
    [Symbol.toStringTag](): string;
}
declare type PeelTupleSyntaxRule<R> = {
    [k in keyof R]: R[k] extends SyntaxRule<infer T> ? T : never;
};
/** Wraps `[A, B, C]` into `[SyntaxRule<A>, SyntaxRule<B>, SyntaxRule<C>]`. */
declare type WrapTupleSyntaxRule<R> = {
    [k in keyof R]: SyntaxRule<R[k]>;
};
/** Returns type of tuple items as an union: `[A, B, C]` -> `A | B | C`. */
declare type TupleItemsUnion<T> = T extends (infer E)[] ? E : never;
export declare class SyntaxRuleOr<T extends readonly unknown[]> extends SyntaxRule<TupleItemsUnion<T>> {
    readonly rules: WrapTupleSyntaxRule<T>;
    constructor(...rules: WrapTupleSyntaxRule<T>);
    tryMatch(tokens: LexerTokenStream): RuleResult<TupleItemsUnion<T>>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleFollowedBy<T extends readonly unknown[]> extends SyntaxRule<T> {
    readonly rules: WrapTupleSyntaxRule<T>;
    constructor(...rules: WrapTupleSyntaxRule<T>);
    tryMatch(tokens: LexerTokenStream): RuleResult<T>;
    [Symbol.toStringTag](): string;
}
/** Matches one or more occurences of `rule`. */
export declare class SyntaxRuleRepeat<R> extends SyntaxRule<[R, ...R[]]> {
    readonly rule: SyntaxRule<R>;
    constructor(rule: SyntaxRule<R>);
    tryMatch(tokens: LexerTokenStream): RuleResult<[R, ...R[]]>;
    [Symbol.toStringTag](): string;
}
/** Matches zero or one occurences of `rule`. */
export declare class SyntaxRuleOptional<R> extends SyntaxRule<R | undefined> {
    readonly rule: SyntaxRule<R>;
    constructor(rule: SyntaxRule<R>);
    tryMatch(tokens: LexerTokenStream): RuleResultMatch<R | undefined>;
    [Symbol.toStringTag](): string;
}
/** Matches rule and then restores `tokens` state. */
export declare class SyntaxRuleLookahead<R> extends SyntaxRule<undefined> {
    readonly rule: SyntaxRule<R>;
    /**
     * Invert the lookahead, matching if the inner rule fails.
     */
    readonly invert: boolean;
    constructor(rule: SyntaxRule<R>, invert?: boolean);
    tryMatch(tokens: LexerTokenStream): RuleResult<undefined>;
    [Symbol.toStringTag](): string;
}
/** Maps `match` value on success. */
export declare class SyntaxRuleMap<R, M> extends SyntaxRule<M> {
    readonly rule: SyntaxRule<R>;
    readonly mapper: (_: R) => M;
    constructor(rule: SyntaxRule<R>, mapper: (_: R) => M);
    tryMatch(tokens: LexerTokenStream): RuleResult<M>;
    [Symbol.toStringTag](): string;
}
declare type AndThenResult<T> = {
    kind: 'match';
    value: T;
} | {
    kind: 'nomatch';
};
export declare class SyntaxRuleAndThen<R, M> extends SyntaxRule<M> {
    readonly rule: SyntaxRule<R>;
    readonly then: (_: R) => AndThenResult<M>;
    readonly description?: string | undefined;
    constructor(rule: SyntaxRule<R>, then: (_: R) => AndThenResult<M>, description?: string | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<M>;
    [Symbol.toStringTag](): string;
}
/**
 * Mutable rule.
 *
 * Since the syntax tree node types are recursive, it follows that the rule definitions must be too.
 * However, there is no way to achieve constant recursiveness - e.g. mutability must be used.
 *
 * This rule provides the option to mutate the inner rule after the object has been created
 * to allow for this mutability. However, it should not be used outside the usecase.
 */
export declare class SyntaxRuleMutable<R> extends SyntaxRule<R> {
    rule?: SyntaxRule<R> | undefined;
    constructor(rule?: SyntaxRule<R> | undefined);
    tryMatch(tokens: LexerTokenStream): RuleResult<R>;
    [Symbol.toStringTag](): string;
}
/**
 * Never rules.
 *
 * This rule never matches.
 */
export declare class SyntaxRuleNever<R> extends SyntaxRule<R> {
    constructor();
    tryMatch(tokens: LexerTokenStream): RuleResult<R>;
    [Symbol.toStringTag](): string;
}
export declare class SyntaxRuleDebugLog<R> extends SyntaxRule<R> {
    readonly rule: SyntaxRule<R>;
    constructor(rule: SyntaxRule<R>);
    tryMatch(tokens: LexerTokenStream): RuleResult<R>;
    [Symbol.toStringTag](): string;
}
export {};

"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PROFILE_DOCUMENT = exports.PROFILE_DOCUMENT_DEFINITION = exports.PROFILE_HEADER = exports.USECASE_DEFINITION = exports.NAMED_MODEL_DEFINITION = exports.NAMED_FIELD_DEFINITION = exports.FIELD_DEFINITION = exports.TYPE = exports.LIST_DEFINITION = exports.OBJECT_DEFINITION = exports.MODEL_TYPE_NAME = exports.ENUM_DEFINITION = exports.ENUM_VALUE = exports.PRIMITIVE_TYPE_NAME = void 0;
var parser_1 = require("../../../../common/document/parser");
var version_1 = require("../../../../common/document/version");
var metadata_1 = require("../../../../metadata");
var rule_1 = require("../../rule");
var common_1 = require("../common");
var literal_1 = require("./literal");
// MUTABLE RULES //
// These rules need to use mutability to achieve recursion and they make use of the `SyntaxRuleMutable` rule
var TYPE_MUT = new rule_1.SyntaxRuleMutable();
var FIELD_DEFINITION_MUT = new rule_1.SyntaxRuleMutable();
// TYPES //
/** From keywords: `boolean`, `number` and `string` */
exports.PRIMITIVE_TYPE_NAME = new rule_1.SyntaxRuleOr(rule_1.SyntaxRule.identifier('boolean'), rule_1.SyntaxRule.identifier('number'), rule_1.SyntaxRule.identifier('string')).map(function (keywordMatch) {
    var name;
    switch (keywordMatch.data.identifier) {
        case 'number':
            name = 'number';
            break;
        case 'string':
            name = 'string';
            break;
        case 'boolean':
            name = 'boolean';
            break;
        default:
            throw 'Unexpected soft keyword. This is an error in the syntax rule definition';
    }
    return {
        kind: 'PrimitiveTypeName',
        name: name,
        location: keywordMatch.location,
    };
});
exports.ENUM_VALUE = (0, common_1.documentedNode)((0, common_1.expectTerminated)(rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.identifier(), rule_1.SyntaxRule.optional(rule_1.SyntaxRule.operator('=').followedBy(rule_1.SyntaxRule.literal().or(rule_1.SyntaxRule.string())))), ',', '}', '\n').map(function (_a) {
    var _b = __read(_a, 2), name = _b[0], maybeAssignment = _b[1];
    var variantName = name.data.identifier;
    var variantValue;
    if (maybeAssignment === undefined) {
        variantValue = variantName;
    }
    else {
        var match = maybeAssignment[1];
        switch (match.data.kind) {
            case 3 /* LITERAL */:
                variantValue = match.data.literal;
                break;
            case 4 /* STRING */:
                variantValue = match.data.string;
                break;
            default:
                throw new Error('Unexpected token kind. This is an error in the syntax rule definition');
        }
    }
    return {
        kind: 'EnumValue',
        name: variantName,
        value: variantValue,
        location: common_1.computeLocationSpan.apply(void 0, __spreadArray([name], __read((maybeAssignment !== null && maybeAssignment !== void 0 ? maybeAssignment : [])), false)),
    };
}));
/** Construct of form: `enum { values... }` */
exports.ENUM_DEFINITION = rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.identifier('enum'), rule_1.SyntaxRule.separator('{'), rule_1.SyntaxRule.repeat(exports.ENUM_VALUE), rule_1.SyntaxRule.separator('}')).map(function (_a) {
    var _b = __read(_a, 4), keyword = _b[0], _sepStart = _b[1], values = _b[2], sepEnd = _b[3];
    return {
        kind: 'EnumDefinition',
        values: values,
        location: (0, common_1.computeLocationSpan)(keyword, sepEnd),
    };
});
/** Name of a model type parsed from identifiers. */
exports.MODEL_TYPE_NAME = rule_1.SyntaxRule.identifier().map(function (name) {
    return {
        kind: 'ModelTypeName',
        name: name.data.identifier,
        location: (0, common_1.computeLocationSpan)(name),
    };
});
/** Construct of form: `{ fields... }` */
exports.OBJECT_DEFINITION = rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.separator('{'), rule_1.SyntaxRule.optionalRepeat(FIELD_DEFINITION_MUT), rule_1.SyntaxRule.separator('}')).map(function (_a) {
    var _b = __read(_a, 3), sepStart = _b[0], maybeFields = _b[1], sepEnd = _b[2];
    return {
        kind: 'ObjectDefinition',
        fields: maybeFields !== null && maybeFields !== void 0 ? maybeFields : [],
        location: (0, common_1.computeLocationSpan)(sepStart, sepEnd),
    };
});
// Helper rule to ensure correct precedence
//
// MODEL must go after both PRIMITIVE and ENUM
var BASIC_TYPE = rule_1.SyntaxRule.or(exports.PRIMITIVE_TYPE_NAME, exports.ENUM_DEFINITION, exports.MODEL_TYPE_NAME, exports.OBJECT_DEFINITION);
/** Array type: `[type]` */
exports.LIST_DEFINITION = rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.separator('['), TYPE_MUT, rule_1.SyntaxRule.separator(']')).map(function (_a) {
    var _b = __read(_a, 3), sepStart = _b[0], type = _b[1], sepEnd = _b[2];
    return {
        kind: 'ListDefinition',
        elementType: type,
        location: (0, common_1.computeLocationSpan)(sepStart, sepEnd),
    };
});
var NON_UNION_TYPE = BASIC_TYPE.or(exports.LIST_DEFINITION)
    .followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.operator('!')))
    .map(function (_a) {
    var _b = __read(_a, 2), type = _b[0], maybeOp = _b[1];
    if (maybeOp !== undefined) {
        return {
            kind: 'NonNullDefinition',
            type: type,
            location: (0, common_1.computeLocationSpan)(type, maybeOp),
        };
    }
    return type;
});
exports.TYPE = NON_UNION_TYPE.followedBy(rule_1.SyntaxRule.optionalRepeat(rule_1.SyntaxRule.operator('|').followedBy(NON_UNION_TYPE))).map(function (_a) {
    var _b = __read(_a, 2), firstType = _b[0], maybeRestPairs = _b[1];
    // Handle unions
    if (maybeRestPairs !== undefined) {
        var types = __spreadArray([firstType], __read(maybeRestPairs.map(function (_a) {
            var _b = __read(_a, 2), _op = _b[0], type = _b[1];
            return type;
        })), false);
        return {
            kind: 'UnionDefinition',
            types: types,
            location: common_1.computeLocationSpan.apply(void 0, __spreadArray([firstType], __read(types), false)),
        };
    }
    return firstType;
});
TYPE_MUT.rule = exports.TYPE;
// FIELDS //
exports.FIELD_DEFINITION = (0, common_1.documentedNode)((0, common_1.expectTerminated)(rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.identifier(), rule_1.SyntaxRule.optional(rule_1.SyntaxRule.operator('!')), rule_1.SyntaxRule.optional(rule_1.SyntaxRule.sameLine(exports.TYPE))), ',', '}', '\n').map(function (_a) {
    var _b = __read(_a, 3), name = _b[0], maybeRequired = _b[1], maybeType = _b[2];
    return {
        kind: 'FieldDefinition',
        fieldName: name.data.identifier,
        required: maybeRequired !== undefined,
        type: maybeType,
        location: (0, common_1.computeLocationSpan)(name, maybeRequired, maybeType),
    };
}));
FIELD_DEFINITION_MUT.rule = exports.FIELD_DEFINITION;
/** * Construct of form: `field ident type` or `field ident { fields... }` */
exports.NAMED_FIELD_DEFINITION = (0, common_1.documentedNode)(rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.identifier('field'), rule_1.SyntaxRule.identifier(), rule_1.SyntaxRule.optional(rule_1.SyntaxRule.sameLine(exports.TYPE))).map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], fieldName = _b[1], maybeType = _b[2];
    return {
        kind: 'NamedFieldDefinition',
        fieldName: fieldName.data.identifier,
        type: maybeType,
        location: (0, common_1.computeLocationSpan)(keyword, fieldName, maybeType),
    };
}));
// MODEL //
/** Construct of form: `model ident type` or `model ident { fields... }` */
exports.NAMED_MODEL_DEFINITION = (0, common_1.documentedNode)(rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.identifier('model'), rule_1.SyntaxRule.identifier(), rule_1.SyntaxRule.optional(rule_1.SyntaxRule.sameLine(exports.TYPE))).map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], modelName = _b[1], maybeType = _b[2];
    return {
        kind: 'NamedModelDefinition',
        modelName: modelName.data.identifier,
        type: maybeType,
        location: (0, common_1.computeLocationSpan)(keyword, modelName, maybeType),
    };
}));
function SLOT_FACTORY(names, rule) {
    var namesRule = rule_1.SyntaxRule.followedBy.apply(rule_1.SyntaxRule, __spreadArray([rule_1.SyntaxRule.identifier(names[0])], __read(names.slice(1).map(function (n) { return rule_1.SyntaxRule.sameLine(rule_1.SyntaxRule.identifier(n)); })), false));
    var slotrule = namesRule
        .followedBy(rule_1.SyntaxRule.sameLine(rule))
        .map(function (_a) {
        var _b = __read(_a, 2), names = _b[0], value = _b[1];
        return {
            value: value,
            location: common_1.computeLocationSpan.apply(void 0, __spreadArray(__spreadArray([], __read(names), false), [value], false)),
        };
    });
    return (0, common_1.documentedNode)(slotrule);
}
function USECASE_SLOT_DEFINITION_FACTORY(names, rule) {
    return SLOT_FACTORY(names, rule).map(function (slot) {
        return {
            kind: 'UseCaseSlotDefinition',
            value: slot.value,
            location: slot.location,
            documentation: slot.documentation,
        };
    });
}
var USECASE_SAFETY = rule_1.SyntaxRule.identifier('safe')
    .or(rule_1.SyntaxRule.identifier('unsafe'))
    .or(rule_1.SyntaxRule.identifier('idempotent'));
var USECASE_EXAMPLE = rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.optional(rule_1.SyntaxRule.identifier()), rule_1.SyntaxRule.separator('{'), rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['input'], literal_1.COMLINK_OBJECT_LITERAL)), rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['result'], literal_1.COMLINK_LITERAL)), rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['async', 'result'], literal_1.COMLINK_LITERAL)), rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['error'], literal_1.COMLINK_LITERAL)), rule_1.SyntaxRule.separator('}')).andThen(function (_a) {
    var _b = __read(_a, 7), maybeName = _b[0], sepStart = _b[1], maybeInput = _b[2], maybeResult = _b[3], maybeAsyncResult = _b[4], maybeError = _b[5], sepEnd = _b[6];
    if (maybeError !== undefined &&
        (maybeResult !== undefined || maybeAsyncResult !== undefined)) {
        return { kind: 'nomatch' };
    }
    var value = {
        kind: 'UseCaseExample',
        exampleName: maybeName === null || maybeName === void 0 ? void 0 : maybeName.data.identifier,
        input: maybeInput,
        result: maybeResult,
        asyncResult: maybeAsyncResult,
        error: maybeError,
        location: (0, common_1.computeLocationSpan)(maybeName, sepStart, sepEnd),
    };
    return { kind: 'match', value: value };
});
/**
* Construct of form:
```
usecase ident safety {
  input { fields... }
  result type
  error type
}
```
*/
exports.USECASE_DEFINITION = (0, common_1.documentedNode)(rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.identifier('usecase'), rule_1.SyntaxRule.identifier(undefined), rule_1.SyntaxRule.optional(USECASE_SAFETY), rule_1.SyntaxRule.separator('{'), rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['input'], exports.OBJECT_DEFINITION)), rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['result'], exports.TYPE)), rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['async', 'result'], exports.TYPE)), rule_1.SyntaxRule.optional(USECASE_SLOT_DEFINITION_FACTORY(['error'], exports.TYPE)), rule_1.SyntaxRule.optionalRepeat(USECASE_SLOT_DEFINITION_FACTORY(['example'], USECASE_EXAMPLE)), rule_1.SyntaxRule.separator('}')).map(function (_a) {
    var _b = __read(_a, 10), keyword = _b[0], name = _b[1], maybeSafety = _b[2], _sepStart = _b[3], maybeInput = _b[4], maybeResult = _b[5], maybeAsyncResult = _b[6], maybeError = _b[7], maybeExamples = _b[8], sepEnd = _b[9];
    var safety = undefined;
    switch (maybeSafety === null || maybeSafety === void 0 ? void 0 : maybeSafety.data.identifier) {
        case undefined:
            break;
        case 'safe':
            safety = 'safe';
            break;
        case 'unsafe':
            safety = 'unsafe';
            break;
        case 'idempotent':
            safety = 'idempotent';
            break;
        default:
            throw 'Unexpected soft keyword. This is an error in the syntax rule definition';
    }
    return {
        kind: 'UseCaseDefinition',
        useCaseName: name.data.identifier,
        safety: safety,
        input: maybeInput,
        result: maybeResult,
        asyncResult: maybeAsyncResult,
        error: maybeError,
        examples: maybeExamples,
        location: (0, common_1.computeLocationSpan)(keyword, sepEnd),
    };
}));
// DOCUMENT //
var PROFILE_NAME = rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.identifier('name'), rule_1.SyntaxRuleSeparator.operator('='), rule_1.SyntaxRule.string().andThen(function (name) {
    var parseNameResult = (0, parser_1.parseDocumentId)(name.data.string);
    // profiles can't have version specified in the name
    if (parseNameResult.kind !== 'parsed' ||
        parseNameResult.value.middle.length !== 1 ||
        parseNameResult.value.version !== undefined) {
        return {
            kind: 'nomatch',
        };
    }
    var parsedName = parseNameResult.value;
    return {
        kind: 'match',
        value: {
            scope: parsedName.scope,
            name: parsedName.middle[0],
            location: name.location,
        },
    };
}, 'profile name in format `[<scope>/]<name>` with lowercase identifier')).map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], op = _b[1], name = _b[2];
    return {
        scope: name.scope,
        name: name.name,
        location: (0, common_1.computeLocationSpan)(keyword, op, name),
    };
});
var PROFILE_VERSION = rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.identifier('version'), rule_1.SyntaxRuleSeparator.operator('='), rule_1.SyntaxRule.string().andThen(function (version) {
    var _a, _b;
    try {
        var parsedVersion = version_1.VersionRange.fromString(version.data.string);
        return {
            kind: 'match',
            value: {
                major: parsedVersion.major,
                minor: (_a = parsedVersion.minor) !== null && _a !== void 0 ? _a : 0,
                patch: (_b = parsedVersion.patch) !== null && _b !== void 0 ? _b : 0,
                label: parsedVersion.label,
                location: version.location,
            },
        };
    }
    catch (error) {
        return { kind: 'nomatch' };
    }
}, 'semver version')).map(function (_a) {
    var _b = __read(_a, 3), keyword = _b[0], op = _b[1], version = _b[2];
    return {
        version: {
            major: version.major,
            minor: version.minor,
            patch: version.patch,
        },
        location: (0, common_1.computeLocationSpan)(keyword, op, version),
    };
});
exports.PROFILE_HEADER = (0, common_1.documentedNode)(PROFILE_NAME.followedBy(PROFILE_VERSION).map(function (_a) {
    var _b = __read(_a, 2), name = _b[0], version = _b[1];
    return {
        kind: 'ProfileHeader',
        scope: name.scope,
        name: name.name,
        version: version.version,
        location: (0, common_1.computeLocationSpan)(name, version),
    };
}));
exports.PROFILE_DOCUMENT_DEFINITION = exports.USECASE_DEFINITION.or(exports.NAMED_FIELD_DEFINITION).or(exports.NAMED_MODEL_DEFINITION);
exports.PROFILE_DOCUMENT = rule_1.SyntaxRule.followedBy(rule_1.SyntaxRule.separator('SOF'), exports.PROFILE_HEADER, rule_1.SyntaxRule.optionalRepeat(exports.PROFILE_DOCUMENT_DEFINITION), rule_1.SyntaxRule.separator('EOF'), new common_1.SyntaxRuleSourceChecksum()).map(function (_a) {
    var _b = __read(_a, 5), _SOF = _b[0], header = _b[1], maybeDefinitions = _b[2], _EOF = _b[3], sourceChecksum = _b[4];
    var definitions = maybeDefinitions !== null && maybeDefinitions !== void 0 ? maybeDefinitions : [];
    return {
        kind: 'ProfileDocument',
        header: header,
        definitions: definitions,
        location: common_1.computeLocationSpan.apply(void 0, __spreadArray([header], __read(definitions), false)),
        astMetadata: {
            astVersion: metadata_1.PARSED_AST_VERSION,
            parserVersion: metadata_1.PARSED_VERSION,
            sourceChecksum: sourceChecksum,
        },
    };
});
//# sourceMappingURL=profile.js.map
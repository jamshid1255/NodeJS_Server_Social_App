"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LexerToken = exports.formatTokenData = exports.formatTokenKind = exports.LITERALS_BOOL = exports.OPERATORS = exports.SEPARATORS = void 0;
var source_1 = require("../../common/source");
exports.SEPARATORS = {
    '(': ['(', source_1.isAny],
    ')': [')', source_1.isAny],
    '[': ['[', source_1.isAny],
    ']': [']', source_1.isAny],
    '{': ['{', source_1.isAny],
    '}': ['}', source_1.isAny],
};
exports.OPERATORS = {
    ':': [':', source_1.isAny],
    '!': ['!', source_1.isAny],
    '|': ['|', source_1.isAny],
    '=': ['=', source_1.isAny],
    '@': ['@', source_1.isAny],
    ',': [',', source_1.isAny],
    ';': [';', source_1.isAny],
    '.': ['.', source_1.isAny],
};
// Literals
exports.LITERALS_BOOL = {
    true: [true, source_1.isNotValidIdentifierChar],
    false: [false, source_1.isNotValidIdentifierChar],
};
function formatTokenKind(kind) {
    switch (kind) {
        case 0 /* UNKNOWN */:
            return 'unknown';
        case 1 /* SEPARATOR */:
            return 'separator';
        case 2 /* OPERATOR */:
            return 'operator';
        case 3 /* LITERAL */:
            return 'number or boolean literal';
        case 4 /* STRING */:
            return 'string';
        case 5 /* IDENTIFIER */:
            return 'identifier';
        case 6 /* COMMENT */:
            return 'comment';
        case 7 /* NEWLINE */:
            return 'newline';
        case 8 /* JESSIE_SCRIPT */:
            return 'jessie script';
    }
}
exports.formatTokenKind = formatTokenKind;
function formatTokenData(data) {
    var kind = formatTokenKind(data.kind);
    switch (data.kind) {
        case 0 /* UNKNOWN */:
            return { kind: kind, data: 'unknown' };
        case 1 /* SEPARATOR */:
            return { kind: kind, data: data.separator.toString() };
        case 2 /* OPERATOR */:
            return { kind: kind, data: data.operator.toString() };
        case 3 /* LITERAL */:
            return { kind: kind, data: data.literal.toString() };
        case 4 /* STRING */:
            return { kind: kind, data: data.string.toString() };
        case 5 /* IDENTIFIER */:
            return { kind: kind, data: data.identifier.toString() };
        case 6 /* COMMENT */:
            return { kind: kind, data: data.comment.toString() };
        case 7 /* NEWLINE */:
            return { kind: kind, data: '\n' };
        case 8 /* JESSIE_SCRIPT */:
            return { kind: kind, data: data.script.toString() };
    }
}
exports.formatTokenData = formatTokenData;
// Token class //
var LexerToken = /** @class */ (function () {
    function LexerToken(
    /** Data of the token. */
    data, location) {
        this.data = data;
        this.location = location;
    }
    LexerToken.prototype.isSOF = function () {
        return (this.data.kind == 1 /* SEPARATOR */ &&
            this.data.separator === 'SOF');
    };
    LexerToken.prototype.isEOF = function () {
        return (this.data.kind == 1 /* SEPARATOR */ &&
            this.data.separator === 'EOF');
    };
    LexerToken.prototype.toStringDebug = function () {
        var loc = "".concat(this.location.start.line, ":").concat(this.location.start.column, ";").concat(this.location.end.line, ":").concat(this.location.end.column);
        var span = "".concat(this.location.start.charIndex, ";").concat(this.location.end.charIndex);
        return "{".concat(this.toString(), "}@(").concat(loc, ")[").concat(span, "]");
    };
    LexerToken.prototype.toString = function () {
        return this[Symbol.toStringTag]();
    };
    LexerToken.prototype[Symbol.toStringTag] = function () {
        var fmt = formatTokenData(this.data);
        return "".concat(fmt.kind, " `").concat(fmt.data, "`");
    };
    return LexerToken;
}());
exports.LexerToken = LexerToken;
//# sourceMappingURL=token.js.map
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapId = exports.DEFAULT_MAP_VERSION = exports.MapVersion = void 0;
var ast_1 = require("@superfaceai/ast");
var parser_1 = require("./parser");
/**
 * Class representing map version, every property except patch and label is required
 * Difference between this class and VersionRange is in optionality of properties - VersionRange is a more abstract structure
 */
var MapVersion = /** @class */ (function () {
    function MapVersion(major, minor, revision) {
        this.major = major;
        this.minor = minor;
        this.revision = revision;
    }
    MapVersion.fromVersionRange = function (input) {
        if (input.minor === undefined) {
            throw new Error("Invalid map version: ".concat(input.toString(), " - minor version is required"));
        }
        var revision = undefined;
        if (input.label) {
            var parseResult = (0, parser_1.parseRevisionLabel)(input.label);
            if (parseResult.kind === 'error') {
                throw new Error("Invalid map version: ".concat(input.toString(), " - revision has error: ").concat(parseResult.message));
            }
            revision = parseResult.value;
        }
        return new MapVersion(input.major, input.minor, revision);
    };
    MapVersion.fromString = function (input) {
        var _a = __read((0, ast_1.splitLimit)(input, '-', 1), 2), restVersion = _a[0], label = _a[1];
        var _b = __read((0, ast_1.splitLimit)(restVersion, '.', 1), 2), majorStr = _b[0], minorStr = _b[1];
        var major = (0, parser_1.tryParseVersionNumber)(majorStr);
        if (major === undefined) {
            throw new Error("Invalid map version: ".concat(input, " - major component: ").concat(majorStr, " is not a valid number"));
        }
        var minor = (0, parser_1.tryParseVersionNumber)(minorStr);
        if (minor === undefined) {
            throw new Error("Invalid map version: ".concat(input, " - minor component: ").concat(minorStr, " is not a valid number"));
        }
        var revision = undefined;
        if (label) {
            var parseResult = (0, parser_1.parseRevisionLabel)(label);
            if (parseResult.kind === 'error') {
                throw new Error("Invalid map version: ".concat(input.toString(), " - revision has error: ").concat(parseResult.message));
            }
            revision = parseResult.value;
        }
        return new MapVersion(major, minor, revision);
    };
    MapVersion.fromParameters = function (params) {
        return new MapVersion(params.major, params.minor, params.revision);
    };
    MapVersion.prototype.toString = function () {
        var str = "".concat(this.major, ".").concat(this.minor);
        return this.revision !== undefined ? "".concat(str, "-rev").concat(this.revision) : str;
    };
    return MapVersion;
}());
exports.MapVersion = MapVersion;
/**
 * Represents default value of profile version in ProfileId instance
 */
exports.DEFAULT_MAP_VERSION = MapVersion.fromParameters({
    major: 1,
    minor: 0,
});
/**
 * Class representing map id
 */
var MapId = /** @class */ (function () {
    function MapId(profile, version, provider, variant) {
        if (!profile.version) {
            throw new Error("Invalid map id - map version: ".concat(version.toString(), " and undefined profile version does not match"));
        }
        if (profile.version.major !== version.major) {
            throw new Error("Invalid map id - major component of map version: ".concat(version.major, " and major component of profile version: ").concat(profile.version.major, " does not match"));
        }
        if (profile.version.minor !== version.minor) {
            throw new Error("Invalid map id - minor component of map version: ".concat(version.minor, " and minor component of profile version: ").concat(profile.version.minor, " does not match"));
        }
        this.profile = profile;
        this.version = version;
        this.provider = provider;
        this.variant = variant;
    }
    //TODO: fromId
    MapId.fromParameters = function (params) {
        return new MapId(params.profile, params.version, params.provider, params.variant);
    };
    MapId.prototype.toString = function () {
        var id = "".concat(this.profile.withoutVersion, ".").concat(this.provider);
        if (this.variant) {
            id += ".".concat(this.variant);
        }
        return id + "@".concat(this.version.toString());
    };
    return MapId;
}());
exports.MapId = MapId;
//# sourceMappingURL=map.js.map
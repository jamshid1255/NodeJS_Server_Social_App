"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptExpressionCompiler = exports.ScriptCompiler = void 0;
var ts = __importStar(require("typescript"));
var validator_1 = require("./validator/validator");
// Most of the functionality of this class comes from typescript src/services/transpile.ts
// and related typescript modules which are sadly internal
var ScriptCompiler = /** @class */ (function () {
    function ScriptCompiler(sourceText) {
        this.sourceText = sourceText;
        var compilerOptions = ScriptCompiler.buildTranspileOptions();
        this.sourceFile = ts.createSourceFile(ScriptCompiler.SOURCE_NAME, this.sourceText, ts.ScriptTarget.ESNext, true, ts.ScriptKind.JS);
        var host = ScriptCompiler.buildCompilerHost(ScriptCompiler.SOURCE_NAME, this.sourceFile, ScriptCompiler.getNewLineCharacter(compilerOptions));
        this.tsProgram = ts.createProgram([ScriptCompiler.SOURCE_NAME], compilerOptions, host);
    }
    ScriptCompiler.buildTranspileOptions = function () {
        var options = __assign(__assign(__assign({}, ts.getDefaultCompilerOptions()), {
            allowJs: true,
            target: ScriptCompiler.TRANSPILE_TARGET,
            sourceMap: true,
        }), { 
            // these are forced for transpilation mode by typescript
            // incremental: undefined,
            // lib: undefined,
            // declaration: undefined,
            // declarationMap: undefined,
            // emitDeclarationOnly: undefined,
            // outFile: undefined,
            // composite: undefined,
            // tsBuildInfoFile: undefined,
            // noEmit: undefined,
            isolatedModules: true, 
            // paths: undefined,
            // rootDirs: undefined,
            // types: undefined,
            // out: undefined,
            noLib: true, noResolve: true });
        return options;
    };
    ScriptCompiler.getNewLineCharacter = function (options) {
        var carriageReturnLineFeed = '\r\n';
        var lineFeed = '\n';
        switch (options.newLine) {
            case ts.NewLineKind.CarriageReturnLineFeed:
                return carriageReturnLineFeed;
            case ts.NewLineKind.LineFeed:
                return lineFeed;
        }
        return ts.sys ? ts.sys.newLine : carriageReturnLineFeed;
    };
    ScriptCompiler.buildCompilerHost = function (fileName, sourceFile, newLine) {
        var host = {
            getSourceFile: function (name) {
                if (name === ScriptCompiler.SOURCE_NAME) {
                    return sourceFile;
                }
                else {
                    return undefined;
                }
            },
            writeFile: function (_name, _text) { return undefined; },
            getDefaultLibFileName: function () { return 'lib.d.ts'; },
            useCaseSensitiveFileNames: function () { return false; },
            getCanonicalFileName: function (name) { return name; },
            getCurrentDirectory: function () { return ''; },
            getNewLine: function () { return newLine; },
            fileExists: function (name) { return name === fileName; },
            readFile: function () { return ''; },
            directoryExists: function () { return true; },
            getDirectories: function () { return []; },
        };
        return host;
    };
    ScriptCompiler.prototype.diagnose = function () {
        return __spreadArray(__spreadArray([], __read(this.tsProgram.getSyntacticDiagnostics(this.sourceFile)), false), __read(this.tsProgram.getOptionsDiagnostics()), false).map(function (diag) {
            var _a, _b, _c;
            var detail = diag.messageText;
            if (typeof detail === 'object') {
                detail = detail.messageText;
            }
            return {
                detail: detail,
                relativeSpan: {
                    start: (_a = diag.start) !== null && _a !== void 0 ? _a : 0,
                    end: ((_b = diag.start) !== null && _b !== void 0 ? _b : 0) + Math.max(1, (_c = diag.length) !== null && _c !== void 0 ? _c : 0),
                },
                hints: [],
            };
        });
    };
    ScriptCompiler.prototype.validate = function () {
        return (0, validator_1.validateScript)(this.sourceFile, this.sourceText);
    };
    ScriptCompiler.prototype.transpile = function () {
        var outputRaw;
        var sourceMapRaw;
        this.tsProgram.emit(undefined, function (name, text) {
            if (name.endsWith('.map')) {
                sourceMapRaw = text;
            }
            else {
                outputRaw = text;
            }
        }, undefined, undefined, 
        // TODO: transformers?
        undefined);
        if (outputRaw === undefined || sourceMapRaw === undefined) {
            throw new Error('Unexpected compiler state');
        }
        var output = outputRaw
            .replace('//# sourceMappingURL=module.js.map', '')
            .trimRight();
        var sourceMapJson = JSON.parse(sourceMapRaw);
        ScriptCompiler.assertSourceMapFormat(sourceMapJson);
        return { output: output, sourceMap: sourceMapJson.mappings };
    };
    ScriptCompiler.assertSourceMapFormat = function (input) {
        // This is necessary because TypeScript cannot correctly narrow type of object properties yet
        var hasMappings = function (inp) {
            return typeof inp === 'object' && inp !== null && 'mappings' in inp;
        };
        if (!hasMappings(input) || typeof input.mappings !== 'string') {
            throw 'Source map JSON is not an object in the correct format';
        }
    };
    ScriptCompiler.SOURCE_NAME = 'module.ts';
    ScriptCompiler.TRANSPILE_TARGET = ts.ScriptTarget.ES3;
    return ScriptCompiler;
}());
exports.ScriptCompiler = ScriptCompiler;
var ScriptExpressionCompiler = /** @class */ (function (_super) {
    __extends(ScriptExpressionCompiler, _super);
    function ScriptExpressionCompiler(sourceExpression) {
        return _super.call(this, ScriptExpressionCompiler.SCRIPT_WRAP.start +
            sourceExpression +
            ScriptExpressionCompiler.SCRIPT_WRAP.end) || this;
    }
    /** @internal */
    ScriptExpressionCompiler.fixupRelativeSpan = function (relativeSpan) {
        return {
            start: relativeSpan.start - ScriptExpressionCompiler.SCRIPT_WRAP.start.length,
            end: relativeSpan.end - ScriptExpressionCompiler.SCRIPT_WRAP.start.length,
        };
    };
    Object.defineProperty(ScriptExpressionCompiler.prototype, "rawExpressionNode", {
        /** @internal */
        get: function () {
            var statement = this.sourceFile.statements[0];
            if (!ts.isVariableStatement(statement)) {
                throw new Error('Invalid script compiler state');
            }
            var declaration = statement.declarationList.declarations[0];
            if (declaration === undefined ||
                !ts.isVariableDeclaration(declaration) ||
                declaration.name.getText() !==
                    ScriptExpressionCompiler.SCRIPT_WRAP.varName ||
                declaration.initializer === undefined) {
                throw new Error('Invalid script compiler state');
            }
            return declaration.initializer;
        },
        enumerable: false,
        configurable: true
    });
    ScriptExpressionCompiler.prototype.diagnose = function () {
        return _super.prototype.diagnose.call(this).map(function (diag) {
            diag.relativeSpan = ScriptExpressionCompiler.fixupRelativeSpan(diag.relativeSpan);
            return diag;
        });
    };
    ScriptExpressionCompiler.prototype.validate = function () {
        return (0, validator_1.validateScript)(this.rawExpressionNode, this.sourceText).map(function (diag) {
            diag.relativeSpan = ScriptExpressionCompiler.fixupRelativeSpan(diag.relativeSpan);
            return diag;
        });
    };
    ScriptExpressionCompiler.prototype.transpile = function () {
        var _a = _super.prototype.transpile.call(this), outputWrapped = _a.output, sourceMapWrapped = _a.sourceMap;
        // With some syntax the transpiler creates a polyfill for the function
        // For example for the spread operator `...`
        // Here we detect that case and wrap the output in an immediatelly invoked function expression
        var output;
        if (!outputWrapped.startsWith(ScriptExpressionCompiler.SCRIPT_WRAP.transpiled.start)) {
            output = "(function() {\n".concat(outputWrapped, "\nreturn ").concat(ScriptExpressionCompiler.SCRIPT_WRAP.transpiled.varName, ";\n})()");
        }
        else {
            // strip the prefix and postfix added by the processing here (to force expression position)
            output = outputWrapped.slice(ScriptExpressionCompiler.SCRIPT_WRAP.transpiled.start.length, outputWrapped.length -
                ScriptExpressionCompiler.SCRIPT_WRAP.transpiled.end.length);
        }
        // TODO: Should patch the source map as well
        return { output: output, sourceMap: sourceMapWrapped };
    };
    ScriptExpressionCompiler.SCRIPT_WRAP = {
        start: 'let __jessieValue = ',
        end: ';',
        varName: '__jessieValue',
        transpiled: {
            start: 'var __jessieValue = ',
            end: ';',
            varName: '__jessieValue',
        },
    };
    return ScriptExpressionCompiler;
}(ScriptCompiler));
exports.ScriptExpressionCompiler = ScriptExpressionCompiler;
//# sourceMappingURL=compiler.js.map
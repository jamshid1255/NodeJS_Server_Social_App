"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RETURN_CONSTRUCTS = exports.visitConstruct = void 0;
var ts = __importStar(require("typescript"));
var _1 = require(".");
var profile_output_utils_1 = require("./profile-output.utils");
var utils_1 = require("./utils");
var VALID_CONSTRUCT_RESULT = {
    pass: true,
    invalidInput: false,
    invalidOutput: false,
    warnings: [],
};
function mergeResults() {
    var results = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        results[_i] = arguments[_i];
    }
    return results.reduce(function (acc, val) {
        var _a, _b, _c, _d;
        var pass = acc.pass && val.pass;
        var errors = __spreadArray(__spreadArray([], __read((!acc.pass ? acc.errors : [])), false), __read((!val.pass ? val.errors : [])), false);
        var warnings = __spreadArray(__spreadArray([], __read(((_a = acc.warnings) !== null && _a !== void 0 ? _a : [])), false), __read(((_b = val.warnings) !== null && _b !== void 0 ? _b : [])), false);
        var variables = __spreadArray(__spreadArray([], __read(((_c = acc.variables) !== null && _c !== void 0 ? _c : [])), false), __read(((_d = val.variables) !== null && _d !== void 0 ? _d : [])), false);
        var invalidInput = acc.invalidInput || val.invalidInput;
        var invalidOutput = acc.invalidOutput || val.invalidOutput;
        return pass
            ? {
                pass: pass,
                warnings: warnings,
                variables: variables,
                invalidInput: invalidInput,
                invalidOutput: invalidOutput,
            }
            : {
                pass: pass,
                errors: errors,
                warnings: warnings,
                variables: variables,
                invalidInput: invalidInput,
                invalidOutput: invalidOutput,
            };
    }, VALID_CONSTRUCT_RESULT);
}
function getPath(node) {
    return {
        kind: ts.SyntaxKind[node.kind],
        relativeSpan: { start: node.getStart(), end: node.getEnd() },
    };
}
function isTypescriptIdentifier(node) {
    return ((ts.isIdentifier(node) ||
        ts.isPropertyAccessExpression(node) ||
        ts.isElementAccessExpression(node)) &&
        (0, utils_1.getVariableName)(node) !== 'undefined');
}
function compareStructures(node, inputStructure, outputStructure) {
    if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
        outputStructure = outputStructure.value;
    }
    if ((0, profile_output_utils_1.isNonNullStructure)(inputStructure)) {
        inputStructure = inputStructure.value;
    }
    if ((0, profile_output_utils_1.isScalarStructure)(outputStructure) || (0, profile_output_utils_1.isScalarStructure)(inputStructure)) {
        return VALID_CONSTRUCT_RESULT;
    }
    if ((0, profile_output_utils_1.isEnumStructure)(outputStructure) &&
        (0, profile_output_utils_1.isEnumStructure)(inputStructure) &&
        outputStructure.enums === inputStructure.enums) {
        return VALID_CONSTRUCT_RESULT;
    }
    if ((0, profile_output_utils_1.isListStructure)(outputStructure) &&
        (0, profile_output_utils_1.isListStructure)(inputStructure) &&
        outputStructure.value === inputStructure.value) {
        return VALID_CONSTRUCT_RESULT;
    }
    if ((0, profile_output_utils_1.isObjectStructure)(outputStructure) &&
        (0, profile_output_utils_1.isObjectStructure)(inputStructure) &&
        outputStructure.fields === inputStructure.fields) {
        return VALID_CONSTRUCT_RESULT;
    }
    if ((0, profile_output_utils_1.isPrimitiveStructure)(outputStructure) &&
        (0, profile_output_utils_1.isPrimitiveStructure)(inputStructure) &&
        outputStructure.type === inputStructure.type) {
        return VALID_CONSTRUCT_RESULT;
    }
    if ((0, profile_output_utils_1.isUnionStructure)(outputStructure) &&
        (0, profile_output_utils_1.isUnionStructure)(inputStructure) &&
        outputStructure.types === inputStructure.types) {
        return VALID_CONSTRUCT_RESULT;
    }
    return {
        pass: false,
        errors: [
            {
                kind: 'wrongInput',
                context: {
                    path: getPath(node),
                    expected: outputStructure,
                    actual: inputStructure,
                },
            },
        ],
        warnings: [],
        invalidInput: false,
        invalidOutput: true,
    };
}
function visitConstruct(node, outputStructure, inputStructure, isOutcomeWithCondition, construct) {
    return construct
        ? construct.visit(node, outputStructure, inputStructure, isOutcomeWithCondition)
        : VALID_CONSTRUCT_RESULT;
}
exports.visitConstruct = visitConstruct;
function returnIssue(issue, invalidInput, invalidOutput, isOutcomeWithCondition) {
    return isOutcomeWithCondition
        ? {
            pass: true,
            warnings: [issue],
            invalidInput: invalidInput,
            invalidOutput: invalidOutput,
        }
        : {
            pass: false,
            warnings: [],
            errors: [issue],
            invalidInput: invalidInput,
            invalidOutput: invalidOutput,
        };
}
function getFieldStructure(property, node, objectStructure) {
    if (ts.isIdentifier(node)) {
        if (!objectStructure.fields) {
            throw new Error('Validated object structure does not contain fields');
        }
        return objectStructure.fields[property];
    }
    else if (ts.isPropertyAccessExpression(node)) {
        var structure = (0, utils_1.validateObjectStructure)(node, objectStructure);
        if (structure && (0, profile_output_utils_1.isNonNullStructure)(structure)) {
            structure = structure.value;
        }
        if (!structure || !(0, profile_output_utils_1.isObjectStructure)(structure) || !structure.fields) {
            return undefined;
        }
        return structure.fields[property];
    }
    return undefined;
}
exports.RETURN_CONSTRUCTS = (_a = {},
    _a[ts.SyntaxKind.FirstTemplateToken] = {
        visit: function (node, outputStructure, _inputStructure, isOutcomeWithCondition) {
            return visitConstruct(node, outputStructure, _inputStructure, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[ts.SyntaxKind.StringLiteral]);
        },
    },
    _a[ts.SyntaxKind.StringLiteral] = {
        visit: function (node, outputStructure, _inputStructure, isOutcomeWithCondition) {
            if (!outputStructure) {
                return VALID_CONSTRUCT_RESULT;
            }
            if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
                outputStructure = outputStructure.value;
            }
            // TODO: take `UnionStructure` in consideration
            if ((0, profile_output_utils_1.isScalarStructure)(outputStructure) ||
                (0, profile_output_utils_1.isStringStructure)(outputStructure)) {
                return VALID_CONSTRUCT_RESULT;
            }
            if ((0, profile_output_utils_1.isEnumStructure)(outputStructure)) {
                var enumValues = outputStructure.enums.map(function (value) { return value.value; });
                if (enumValues.includes(node.text)) {
                    return VALID_CONSTRUCT_RESULT;
                }
            }
            return returnIssue({
                kind: 'wrongStructure',
                context: {
                    path: getPath(node),
                    actual: node.text,
                    expected: outputStructure,
                },
            }, false, true, isOutcomeWithCondition);
        },
    },
    _a[ts.SyntaxKind.NumericLiteral] = {
        visit: function (node, outputStructure, _inputStructure, isOutcomeWithCondition) {
            if (!outputStructure) {
                return VALID_CONSTRUCT_RESULT;
            }
            if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
                outputStructure = outputStructure.value;
            }
            // TODO: take `UnionStructure` in consideration
            if ((0, profile_output_utils_1.isScalarStructure)(outputStructure) ||
                (0, profile_output_utils_1.isNumberStructure)(outputStructure)) {
                return VALID_CONSTRUCT_RESULT;
            }
            return returnIssue({
                kind: 'wrongStructure',
                context: {
                    path: getPath(node),
                    actual: node.text,
                    expected: outputStructure,
                },
            }, false, true, isOutcomeWithCondition);
        },
    },
    _a[ts.SyntaxKind.FalseKeyword] = {
        visit: function (node, outputStructure, _inputStructure, isOutcomeWithCondition) {
            if (!outputStructure) {
                return VALID_CONSTRUCT_RESULT;
            }
            if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
                outputStructure = outputStructure.value;
            }
            // TODO: take `UnionStructure` in consideration
            if ((0, profile_output_utils_1.isScalarStructure)(outputStructure) ||
                ((0, profile_output_utils_1.isPrimitiveStructure)(outputStructure) &&
                    (0, profile_output_utils_1.isBooleanStructure)(outputStructure))) {
                return VALID_CONSTRUCT_RESULT;
            }
            return returnIssue({
                kind: 'wrongStructure',
                context: {
                    path: getPath(node),
                    actual: 'false',
                    expected: outputStructure,
                },
            }, false, true, isOutcomeWithCondition);
        },
    },
    _a[ts.SyntaxKind.TrueKeyword] = {
        visit: function (node, outputStructure, _inputStructure, isOutcomeWithCondition) {
            if (!outputStructure) {
                return VALID_CONSTRUCT_RESULT;
            }
            if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
                outputStructure = outputStructure.value;
            }
            // TODO: take `UnionStructure` in consideration
            if ((0, profile_output_utils_1.isScalarStructure)(outputStructure) ||
                ((0, profile_output_utils_1.isPrimitiveStructure)(outputStructure) &&
                    (0, profile_output_utils_1.isBooleanStructure)(outputStructure))) {
                return VALID_CONSTRUCT_RESULT;
            }
            return returnIssue({
                kind: 'wrongStructure',
                context: {
                    path: getPath(node),
                    actual: 'true',
                    expected: outputStructure,
                },
            }, false, true, isOutcomeWithCondition);
        },
    },
    _a[ts.SyntaxKind.NullKeyword] = {
        visit: function (node, outputStructure, _inputStructure, isOutcomeWithCondition) {
            if (!outputStructure) {
                return VALID_CONSTRUCT_RESULT;
            }
            if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
                return returnIssue({
                    kind: 'wrongStructure',
                    context: {
                        path: getPath(node),
                        actual: 'null',
                        expected: outputStructure,
                    },
                }, false, true, isOutcomeWithCondition);
            }
            return VALID_CONSTRUCT_RESULT;
        },
    },
    _a[ts.SyntaxKind.BinaryExpression] = {
        visit: function (node, outputStructure, inputStructure, isOutcomeWithCondition) {
            var results = [];
            // if Input is defined - check ids in children nodes
            if (inputStructure) {
                if (isTypescriptIdentifier(node.left)) {
                    results.push(visitConstruct(node.left, undefined, inputStructure, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[node.left.kind]));
                }
                if (isTypescriptIdentifier(node.right)) {
                    results.push(visitConstruct(node.right, undefined, inputStructure, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[node.right.kind]));
                }
            }
            // if Output is not defined - do not check validation of result or error
            if (!outputStructure) {
                return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
            }
            // if Output is defined - do check
            if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
                if ((0, profile_output_utils_1.isScalarStructure)(outputStructure.value)) {
                    return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
                }
            }
            if ((0, profile_output_utils_1.isScalarStructure)(outputStructure)) {
                return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
            }
            results.push(visitConstruct(node.left, outputStructure, undefined, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[node.left.kind]), visitConstruct(node.right, outputStructure, undefined, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[node.right.kind]));
            return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
        },
    },
    _a[ts.SyntaxKind.Identifier] = {
        visit: function (node, outputStructure, inputStructure, isOutcomeWithCondition) {
            if (node.text === 'input') {
                if (!inputStructure || !inputStructure.fields) {
                    return returnIssue({
                        kind: 'useCaseSlotNotFound',
                        context: {
                            path: getPath(node),
                            expected: _1.UseCaseSlotType.INPUT,
                            actual: (0, utils_1.getVariableName)(node),
                        },
                    }, true, false, isOutcomeWithCondition);
                }
                if (outputStructure) {
                    return compareStructures(node, inputStructure, outputStructure);
                }
                return VALID_CONSTRUCT_RESULT;
            }
            var variables = [];
            if (outputStructure && !(0, profile_output_utils_1.isScalarStructure)(outputStructure)) {
                if (node.text === 'undefined') {
                    if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
                        return returnIssue({
                            kind: 'wrongStructure',
                            context: {
                                path: getPath(node),
                                actual: (0, utils_1.getVariableName)(node),
                                expected: outputStructure.value,
                            },
                        }, false, true, isOutcomeWithCondition);
                    }
                    else {
                        return VALID_CONSTRUCT_RESULT;
                    }
                }
                variables.push({
                    jessieNode: node,
                    type: outputStructure,
                });
            }
            return __assign(__assign({}, VALID_CONSTRUCT_RESULT), { variables: variables });
        },
    },
    _a[ts.SyntaxKind.PropertyAccessExpression] = {
        visit: function (node, outputStructure, inputStructure, isOutcomeWithCondition) {
            if ((0, utils_1.findTypescriptIdentifier)('input', node.expression)) {
                if ((0, utils_1.findTypescriptProperty)('auth', node.expression)) {
                    return VALID_CONSTRUCT_RESULT;
                }
                if (!inputStructure || !inputStructure.fields) {
                    return returnIssue({
                        kind: 'useCaseSlotNotFound',
                        context: {
                            path: getPath(node),
                            expected: _1.UseCaseSlotType.INPUT,
                            actual: (0, utils_1.getVariableName)(node),
                        },
                    }, true, false, isOutcomeWithCondition);
                }
                var issue = {
                    kind: 'wrongInput',
                    context: {
                        path: getPath(node),
                        expected: inputStructure,
                        actual: (0, utils_1.getVariableName)(node),
                    },
                };
                var property = node.name.text;
                var fieldValue = getFieldStructure(property, node.expression, inputStructure);
                if (!fieldValue) {
                    return returnIssue(issue, true, false, isOutcomeWithCondition);
                }
                if (outputStructure) {
                    return compareStructures(node, fieldValue, outputStructure);
                }
                return VALID_CONSTRUCT_RESULT;
            }
            var variables = [];
            if (outputStructure && !(0, profile_output_utils_1.isScalarStructure)(outputStructure)) {
                variables.push({
                    jessieNode: node,
                    type: outputStructure,
                });
            }
            return __assign(__assign({}, VALID_CONSTRUCT_RESULT), { variables: variables });
        },
    },
    _a[ts.SyntaxKind.ElementAccessExpression] = {
        visit: function (node, outputStructure, inputStructure, isOutcomeWithCondition) {
            if ((0, utils_1.findTypescriptIdentifier)('input', node.expression)) {
                if ((0, utils_1.findTypescriptProperty)('auth', node.expression)) {
                    return VALID_CONSTRUCT_RESULT;
                }
                if (!inputStructure || !inputStructure.fields) {
                    var issue_1 = {
                        kind: 'useCaseSlotNotFound',
                        context: {
                            path: getPath(node),
                            expected: _1.UseCaseSlotType.INPUT,
                            actual: (0, utils_1.getVariableName)(node),
                        },
                    };
                    return returnIssue(issue_1, true, false, isOutcomeWithCondition);
                }
                var issue = {
                    kind: 'wrongInput',
                    context: {
                        path: getPath(node),
                        expected: inputStructure,
                        actual: (0, utils_1.getVariableName)(node),
                    },
                };
                var property = node.argumentExpression.text;
                var fieldValue = getFieldStructure(property, node.expression, inputStructure);
                if (!fieldValue) {
                    return returnIssue(issue, true, false, isOutcomeWithCondition);
                }
                if (outputStructure) {
                    return compareStructures(node, fieldValue, outputStructure);
                }
                return VALID_CONSTRUCT_RESULT;
            }
            var variables = [];
            if (outputStructure && !(0, profile_output_utils_1.isScalarStructure)(outputStructure)) {
                variables.push({
                    jessieNode: node,
                    type: outputStructure,
                });
            }
            return __assign(__assign({}, VALID_CONSTRUCT_RESULT), { variables: variables });
        },
    },
    _a[ts.SyntaxKind.ObjectLiteralExpression] = {
        visit: function (node, outputStructure, inputStructure, isOutcomeWithCondition) {
            var e_1, _a, e_2, _b, e_3, _c;
            var results = [];
            // object should only contain property assignments
            var properties = node.properties.filter(ts.isPropertyAssignment);
            if (inputStructure) {
                try {
                    for (var properties_1 = __values(properties), properties_1_1 = properties_1.next(); !properties_1_1.done; properties_1_1 = properties_1.next()) {
                        var property = properties_1_1.value;
                        if (isTypescriptIdentifier(property.initializer)) {
                            results.push(visitConstruct(property.initializer, undefined, inputStructure, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[property.initializer.kind]));
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (properties_1_1 && !properties_1_1.done && (_a = properties_1.return)) _a.call(properties_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            if (!outputStructure) {
                return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
            }
            if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
                outputStructure = outputStructure.value;
            }
            if ((0, profile_output_utils_1.isScalarStructure)(outputStructure)) {
                return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
            }
            // TODO: take `UnionStructure` in consideration
            if (!(0, profile_output_utils_1.isObjectStructure)(outputStructure)) {
                var issue = {
                    kind: 'wrongStructure',
                    context: {
                        path: getPath(node),
                        actual: node.getText(),
                        expected: outputStructure,
                    },
                };
                return mergeResults.apply(void 0, __spreadArray(__spreadArray([], __read(results), false), [returnIssue(issue, false, true, isOutcomeWithCondition)], false));
            }
            var structureOfProperties = outputStructure.fields;
            if (properties.length === 0 && !structureOfProperties) {
                return VALID_CONSTRUCT_RESULT;
            }
            if (!structureOfProperties) {
                throw new Error('Validated object structure does not contain fields');
            }
            // all fields
            var profileProperties = Object.entries(structureOfProperties);
            var profilePropertyNames = Object.keys(structureOfProperties);
            var mapPropertyNames = properties.map(function (property) { return property.name.text; });
            // required fields
            var requiredProperties = profileProperties.filter(function (_a) {
                var _b = __read(_a, 2), value = _b[1];
                return value.required;
            });
            var requiredPropertiesNotFound = requiredProperties.filter(function (_a) {
                var _b = __read(_a, 1), key = _b[0];
                return !mapPropertyNames.includes(key);
            });
            // fields found inside node
            var matchingProperties = properties.filter(function (property) {
                return profilePropertyNames.includes(property.name.text);
            });
            var extraProperties = properties.filter(function (property) {
                return !profilePropertyNames.includes(property.name.text);
            });
            try {
                for (var matchingProperties_1 = __values(matchingProperties), matchingProperties_1_1 = matchingProperties_1.next(); !matchingProperties_1_1.done; matchingProperties_1_1 = matchingProperties_1.next()) {
                    var property = matchingProperties_1_1.value;
                    results.push(visitConstruct(property.initializer, structureOfProperties[property.name.text], undefined, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[property.initializer.kind]));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (matchingProperties_1_1 && !matchingProperties_1_1.done && (_b = matchingProperties_1.return)) _b.call(matchingProperties_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            try {
                for (var requiredPropertiesNotFound_1 = __values(requiredPropertiesNotFound), requiredPropertiesNotFound_1_1 = requiredPropertiesNotFound_1.next(); !requiredPropertiesNotFound_1_1.done; requiredPropertiesNotFound_1_1 = requiredPropertiesNotFound_1.next()) {
                    var _d = __read(requiredPropertiesNotFound_1_1.value, 1), key = _d[0];
                    var issue = {
                        kind: 'missingRequired',
                        context: {
                            path: getPath(node),
                            expected: key,
                        },
                    };
                    results.push(returnIssue(issue, false, true, isOutcomeWithCondition));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (requiredPropertiesNotFound_1_1 && !requiredPropertiesNotFound_1_1.done && (_c = requiredPropertiesNotFound_1.return)) _c.call(requiredPropertiesNotFound_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (extraProperties.length > 0) {
                var issue = {
                    kind: 'wrongObjectStructure',
                    context: {
                        path: getPath(node),
                        expected: outputStructure,
                        actual: node.getText(),
                    },
                };
                results.push(returnIssue(issue, false, false, true));
            }
            return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
        },
    },
    _a[ts.SyntaxKind.ArrayLiteralExpression] = {
        visit: function (node, outputStructure, inputStructure, isOutcomeWithCondition) {
            var e_4, _a, e_5, _b, e_6, _c, e_7, _d;
            var results = [];
            if (inputStructure) {
                try {
                    for (var _e = __values(node.elements), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var element = _f.value;
                        if (isTypescriptIdentifier(element))
                            results.push(visitConstruct(element, undefined, inputStructure, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[element.kind]));
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
            if (!outputStructure) {
                return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
            }
            if ((0, profile_output_utils_1.isNonNullStructure)(outputStructure)) {
                outputStructure = outputStructure.value;
            }
            if ((0, profile_output_utils_1.isScalarStructure)(outputStructure)) {
                return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
            }
            var wrongStructureIssue = {
                kind: 'wrongStructure',
                context: {
                    path: getPath(node),
                    actual: node.getText(),
                    expected: outputStructure,
                },
            };
            // TODO: take `UnionStructure` in consideration
            if (!(0, profile_output_utils_1.isListStructure)(outputStructure)) {
                return mergeResults.apply(void 0, __spreadArray(__spreadArray([], __read(results), false), [returnIssue(wrongStructureIssue, false, true, isOutcomeWithCondition)], false));
            }
            var structureOfTypes;
            var structureOfType;
            if ((0, profile_output_utils_1.isUnionStructure)(outputStructure.value)) {
                structureOfTypes = outputStructure.value.types;
            }
            else {
                structureOfType = outputStructure.value;
            }
            if (structureOfType) {
                try {
                    for (var _g = __values(node.elements), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var element = _h.value;
                        results.push(visitConstruct(element, structureOfType, undefined, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[element.kind]));
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                return mergeResults.apply(void 0, __spreadArray([], __read(results), false));
            }
            if (!structureOfTypes) {
                throw new Error('Validated types in list structure are not defined');
            }
            try {
                for (var _j = __values(node.elements), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var element = _k.value;
                    if (isTypescriptIdentifier(element)) {
                        results.push(visitConstruct(element, outputStructure.value, undefined, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[element.kind]));
                        continue;
                    }
                    var diff = 0;
                    try {
                        for (var structureOfTypes_1 = (e_7 = void 0, __values(structureOfTypes)), structureOfTypes_1_1 = structureOfTypes_1.next(); !structureOfTypes_1_1.done; structureOfTypes_1_1 = structureOfTypes_1.next()) {
                            var value = structureOfTypes_1_1.value;
                            var result = visitConstruct(element, value, undefined, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[element.kind]);
                            if (!result.pass) {
                                diff++;
                            }
                        }
                    }
                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
                    finally {
                        try {
                            if (structureOfTypes_1_1 && !structureOfTypes_1_1.done && (_d = structureOfTypes_1.return)) _d.call(structureOfTypes_1);
                        }
                        finally { if (e_7) throw e_7.error; }
                    }
                    if (diff === structureOfTypes.length) {
                        results.push(returnIssue(wrongStructureIssue, false, true, isOutcomeWithCondition));
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                }
                finally { if (e_6) throw e_6.error; }
            }
            return mergeResults.apply(void 0, __spreadArray(__spreadArray([], __read(results), false), [VALID_CONSTRUCT_RESULT], false));
        },
    },
    _a[ts.SyntaxKind.ParenthesizedExpression] = {
        visit: function (node, outputStructure, inputStructure, isOutcomeWithCondition) {
            return visitConstruct(node.expression, outputStructure, inputStructure, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[node.expression.kind]);
        },
    },
    _a[ts.SyntaxKind.ExpressionStatement] = {
        visit: function (node, outputStructure, inputStructure, isOutcomeWithCondition) {
            return visitConstruct(node.expression, outputStructure, inputStructure, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[node.expression.kind]);
        },
    },
    _a[ts.SyntaxKind.SourceFile] = {
        visit: function (node, outputStructure, inputStructure, isOutcomeWithCondition) {
            var statement = node.statements[node.statements.length - 1];
            return visitConstruct(statement, outputStructure, inputStructure, isOutcomeWithCondition, exports.RETURN_CONSTRUCTS[statement.kind]);
        },
    },
    _a);
//# sourceMappingURL=constructs.js.map
import { MapDocumentNode, NormalizedProfileProviderSettings, ProfileDocumentNode, ProviderJson, SecurityValues } from '@superfaceai/ast';
import { MapInterpreterError, ProfileParameterError } from '../internal/interpreter';
import { SecurityConfiguration } from '../internal/interpreter/http/security';
import { NonPrimitive } from '../internal/interpreter/variables';
import { SuperJson } from '../internal/superjson';
import { Result } from '../lib';
import { Events } from '../lib/events';
import { IServiceSelector } from '../lib/services';
import { ProfileConfiguration } from './profile';
import { ProviderConfiguration } from './provider';
export declare class BoundProfileProvider {
    private readonly profileAst;
    private readonly mapAst;
    private readonly provider;
    readonly configuration: {
        services: IServiceSelector;
        profileProviderSettings?: NormalizedProfileProviderSettings;
        security: SecurityConfiguration[];
        parameters?: Record<string, string>;
    };
    private profileValidator;
    private fetchInstance;
    constructor(profileAst: ProfileDocumentNode, mapAst: MapDocumentNode, provider: ProviderJson, configuration: {
        services: IServiceSelector;
        profileProviderSettings?: NormalizedProfileProviderSettings;
        security: SecurityConfiguration[];
        parameters?: Record<string, string>;
    }, events?: Events);
    private composeInput;
    /**
     * Performs the usecase while validating input and output against the profile definition.
     *
     * Note that the `TInput` and `TResult` types cannot be checked for compatibility with the profile definition, so the caller
     * is responsible for ensuring that the cast is safe.
     */
    perform<TInput extends NonPrimitive | undefined = undefined, TResult = any>(usecase: string, input?: TInput, parameters?: Record<string, string>, securityValues?: SecurityValues[]): Promise<Result<TResult, ProfileParameterError | MapInterpreterError>>;
    private mergeParameters;
}
export declare type BindConfiguration = {
    security?: SecurityValues[];
};
export declare class ProfileProvider {
    /** Preloaded superJson instance */
    readonly superJson: SuperJson;
    /** profile id, url, ast node or configuration instance */
    private profile;
    /** provider name, url or configuration instance */
    private provider;
    private events;
    /** url or ast node */
    private map?;
    private profileId;
    private scope;
    private profileName;
    private providerJson?;
    private readonly cachePath;
    constructor(
    /** Preloaded superJson instance */
    superJson: SuperJson, 
    /** profile id, url, ast node or configuration instance */
    profile: string | ProfileDocumentNode | ProfileConfiguration, 
    /** provider name, url or configuration instance */
    provider: string | ProviderJson | ProviderConfiguration, events: Events, 
    /** url or ast node */
    map?: string | MapDocumentNode | undefined);
    /**
     * Binds the provider.
     *
     * This fetches the unspecified data (provider information and map ast) from registry.
     */
    bind(configuration?: BindConfiguration): Promise<BoundProfileProvider>;
    private resolveIntegrationParameters;
    private cacheProviderInfo;
    private writeProviderCache;
    private resolveProfileAst;
    private resolveProviderInfo;
    private resolveMapAst;
    /**
     * Returns the value resolved from the input.
     *
     * The recognized input values are:
     * * The value itself, returned straight away
     * * `undefined`, returned straight away
     * * File URI that is read and the contents are passed to the `parseFile` function
     * * For other values `unpackNested(input)` is called recursively
     */
    private static resolveValue;
    /**
     * Resolves auth variables by applying the provided overlay over the base variables.
     *
     * The base variables come from super.json
     */
    private resolveSecurityValues;
}

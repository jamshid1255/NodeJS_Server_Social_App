"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unknownProviderInfoError = exports.unknownBindResponseError = exports.bindResponseError = exports.invalidProviderResponseError = exports.unexpectedDigestValue = exports.missingPartOfDigestHeader = exports.digestHeaderNotFound = exports.providersDoNotMatchError = exports.referencedFileNotFoundError = exports.localProviderAndRemoteMapError = exports.invalidProfileProviderError = exports.usecaseNotFoundError = exports.unsupportedContentType = exports.apiKeyInBodyError = exports.missingSecurityValuesError = exports.missingPathReplacementError = exports.invalidBackoffEntryError = exports.invalidSecurityValuesError = exports.securityNotFoundError = exports.serviceNotFoundError = exports.invalidProfileError = exports.unconfiguredProviderError = exports.unconfiguredProviderInPriorityError = exports.providersNotSetError = exports.profileNotFoundError = exports.profileFileNotFoundError = exports.profileNotInstalledError = exports.noConfiguredProviderError = exports.superJsonReadError = exports.superJsonFormatError = exports.superJsonNotAFileError = exports.superJsonNotFoundError = exports.ensureErrorSubclass = void 0;
var ast_1 = require("@superfaceai/ast");
var config_1 = require("../config");
var errors_1 = require("./errors");
function ensureErrorSubclass(error) {
    if (typeof error === 'string') {
        return new Error(error);
    }
    else if (error instanceof Error) {
        return error;
    }
    return new Error(JSON.stringify(error));
}
exports.ensureErrorSubclass = ensureErrorSubclass;
function superJsonNotFoundError(path, error) {
    return new errors_1.SDKExecutionError('Unable to find super.json', ["super.json not found in \"" + path + "\"", error.toString()], []);
}
exports.superJsonNotFoundError = superJsonNotFoundError;
function superJsonNotAFileError(path) {
    return new errors_1.SDKExecutionError('super.json is not a file', ["\"" + path + "\" is not a file"], []);
}
exports.superJsonNotAFileError = superJsonNotAFileError;
function superJsonFormatError(error) {
    return new errors_1.SDKExecutionError('super.json format is invalid', [error.toString()], []);
}
exports.superJsonFormatError = superJsonFormatError;
function superJsonReadError(error) {
    return new errors_1.SDKExecutionError('Unable to read super.json', [error.toString()], []);
}
exports.superJsonReadError = superJsonReadError;
function noConfiguredProviderError(profileId) {
    return new errors_1.SDKExecutionError("No configured provider found for profile: " + profileId, [
        "Profile \"" + profileId + "\" needs at least one configured provider for automatic provider selection",
    ], [
        "Check that a provider is configured for a profile in super.json -> profiles[\"" + profileId + "\"].providers",
        'Providers can be configured using the superface cli tool: `superface configure --help` for more info',
    ]);
}
exports.noConfiguredProviderError = noConfiguredProviderError;
function profileNotInstalledError(profileId) {
    return new errors_1.SDKExecutionError("Profile not installed: " + profileId, [], [
        "Check that the profile is installed in super.json -> profiles[\"" + profileId + "\"]",
        "Profile can be installed using the superface cli tool: `superface install " + profileId + "`",
    ]);
}
exports.profileNotInstalledError = profileNotInstalledError;
function profileFileNotFoundError(file, profileId) {
    return new errors_1.SDKExecutionError("Profile file at path does not exist: " + file, [
        "Profile \"" + profileId + "\" specifies a file path \"" + file + "\" in super.json",
        'but this path does not exist or is not accessible',
    ], [
        "Check that path in super.json -> profiles[\"" + profileId + "\"].file exists and is accessible",
        'Paths in super.json are either absolute or relative to the location of super.json',
    ]);
}
exports.profileFileNotFoundError = profileFileNotFoundError;
function profileNotFoundError(profileName) {
    return new errors_1.SDKExecutionError("Profile \"" + profileName + "\" not found in super.json", [], []);
}
exports.profileNotFoundError = profileNotFoundError;
function providersNotSetError(profileName) {
    return new errors_1.SDKExecutionError("Unable to set priority for \"" + profileName + "\"", ["Providers not set for profile \"" + profileName + "\""], ["Make sure profile " + profileName + " has configured providers."]);
}
exports.providersNotSetError = providersNotSetError;
function unconfiguredProviderInPriorityError(profileId, priority, providers) {
    return new errors_1.SDKExecutionError("Priority array of profile: " + profileId + " contains unconfigured provider", [
        "Profile \"" + profileId + "\" specifies a provider array [" + priority.join(', ') + "] in super.json",
        "but there are only these providers configured [" + providers.join(', ') + "]",
    ], [
        "Check that providers [" + priority.join(', ') + "] are configured for profile \"" + profileId + "\"",
        'Paths in super.json are either absolute or relative to the location of super.json',
    ]);
}
exports.unconfiguredProviderInPriorityError = unconfiguredProviderInPriorityError;
function unconfiguredProviderError(providerName) {
    return new errors_1.SDKExecutionError("Provider not configured: " + providerName, ["Provider \"" + providerName + "\" was not configured in super.json"], [
        'Providers can be configured using the superface cli tool: `superface configure --help` for more info',
    ]);
}
exports.unconfiguredProviderError = unconfiguredProviderError;
function invalidProfileError(profileId) {
    return new errors_1.SDKExecutionError("Invalid profile \"" + profileId + "\"", [], [
        'Check that the profile is installed in super.json -> profiles or that the url is valid',
        'Profiles can be installed using the superface cli tool: `superface install --help` for more info',
    ]);
}
exports.invalidProfileError = invalidProfileError;
function serviceNotFoundError(serviceId, providerName, defaultService) {
    var hints = [];
    if (defaultService) {
        hints = [
            'This appears to be an error in the provider definition. Make sure that the defaultService in provider definition refers to an existing service id',
        ];
    }
    return new errors_1.SDKExecutionError("Service not found: " + serviceId, ["Service \"" + serviceId + "\" for provider \"" + providerName + "\" was not found"], hints);
}
exports.serviceNotFoundError = serviceNotFoundError;
function securityNotFoundError(providerName, definedSchemes, values) {
    return new errors_1.SDKExecutionError("Could not find security scheme for security value with id \"" + values.id + "\"", [
        "The provider definition for \"" + providerName + "\" defines " +
            (definedSchemes.length > 0
                ? "these security schemes: " + definedSchemes.join(', ')
                : 'no security schemes'),
        "but a secret value was provided for security scheme: " + values.id,
    ], [
        "Check that every entry id in super.json -> providers[\"" + providerName + "\"].security refers to an existing security scheme",
        "Make sure any configuration overrides in code for provider \"" + providerName + "\" refer to an existing security scheme",
    ]);
}
exports.securityNotFoundError = securityNotFoundError;
function invalidSecurityValuesError(providerName, type, id, valueKeys, requiredKeys) {
    return new errors_1.SDKExecutionError("Invalid security values for given " + type + " scheme: " + id, [
        "The provided security values with id \"" + id + "\" have keys: " + valueKeys.join(', '),
        "but " + type + " scheme requires: " + requiredKeys.join(', '),
    ], [
        "Check that the entry with id \"" + id + "\" in super.json -> providers[\"" + providerName + "\"].security refers to the correct security scheme",
        "Make sure any configuration overrides in code for provider \"" + providerName + "\" refer to the correct security scheme",
    ]);
}
exports.invalidSecurityValuesError = invalidSecurityValuesError;
function invalidBackoffEntryError(kind) {
    return new errors_1.SDKExecutionError("Invalid backoff entry format: \"" + kind + "\"", [
        "Property \"kind\" in retryPolicy.backoff object has unexpected value \"" + kind + "\"",
        "Property \"kind\" in super.json [profile].providers.[provider].defaults.[usecase].retryPolicy.backoff with value \"" + kind + "\" is not valid",
    ], [
        'Check your super.json',
        "Check property \"kind\" in [profile].providers.[provider].defaults.[usecase].retryPolicy.backoff with value \"" + kind + "\"",
        "Change value of property \"kind\" in retryPolicy.backoff to one of possible values: " + Object.values(ast_1.BackoffKind).join(', '),
    ]);
}
exports.invalidBackoffEntryError = invalidBackoffEntryError;
function missingPathReplacementError(missing, url, all, available) {
    return new errors_1.SDKExecutionError("Missing values for URL path replacement: " + missing.join(', '), [
        "Trying to replace path keys for url: " + url,
        all.length > 0
            ? "Found these path keys: " + all.join(', ')
            : 'Found no path keys',
        available.length > 0
            ? "But only found these potential variables: " + available.join(', ')
            : 'But found no potential variables',
    ], [
        'Make sure the url path variable refers to an available variable',
        'Consider introducing a new variable with the correct name and desired value',
    ]);
}
exports.missingPathReplacementError = missingPathReplacementError;
function missingSecurityValuesError(id) {
    return new errors_1.SDKExecutionError("Security values for security scheme not found: " + id, [
        "Security values for scheme \"" + id + "\" are required by the map",
        'but they were not provided to the sdk',
    ], [
        "Make sure that the security scheme \"" + id + "\" exists in provider definition",
        "Check that either super.json or provider configuration provides security values for the \"" + id + "\" security scheme",
    ]);
}
exports.missingSecurityValuesError = missingSecurityValuesError;
function apiKeyInBodyError(valueLocation, bodyType) {
    return new errors_1.SDKExecutionError('ApiKey in body can be used only on object.', ["Actual " + valueLocation + " is " + bodyType], []);
}
exports.apiKeyInBodyError = apiKeyInBodyError;
function unsupportedContentType(contentType, supportedTypes) {
    return new errors_1.SDKExecutionError("Content type not supported: " + contentType, [
        "Requested content type \"" + contentType + "\"",
        "Supported content types: " + supportedTypes.join(', '),
    ], []);
}
exports.unsupportedContentType = unsupportedContentType;
function usecaseNotFoundError(name, usecases) {
    return new errors_1.SDKExecutionError("Usecase not found: \"" + name + "\"", ["Available usecases: " + usecases.join(', ')], []);
}
exports.usecaseNotFoundError = usecaseNotFoundError;
function invalidProfileProviderError(profileProviderSettings) {
    return new errors_1.SDKExecutionError('Invalid profile provider entry format', ["Settings: " + profileProviderSettings], []);
}
exports.invalidProfileProviderError = invalidProfileProviderError;
function localProviderAndRemoteMapError(providerName, profileId) {
    return new errors_1.SDKExecutionError("Unable to use local provider " + providerName + " and remote profile provider (map)", [
        "Super.json settings: " + profileId + ".providers." + providerName,
        "Super.json settings providers." + providerName,
    ], [
        'Use local provider and profile provider (map)',
        'Use remote provider and profile provider (map)',
        'Use remote provider and local profile provider (map)',
    ]);
}
exports.localProviderAndRemoteMapError = localProviderAndRemoteMapError;
function referencedFileNotFoundError(fileName, extensions) {
    return new errors_1.SDKExecutionError("File referenced in super.json not found: " + fileName, __spreadArray(__spreadArray([
        'Tried to open files:'
    ], __read(extensions.map(function (extension) { return "\t" + fileName + extension; }))), [
        'but none of them were found.',
    ]), []);
}
exports.referencedFileNotFoundError = referencedFileNotFoundError;
function providersDoNotMatchError(mapOrJsonProvider, configProvider, source) {
    return new errors_1.SDKExecutionError("Provider name in " + source + " does not match provider name in configuration", [
        "Map file specifies provider \"" + mapOrJsonProvider + "\".",
        "Configuration specifies provider \"" + configProvider + "\".",
    ], []);
}
exports.providersDoNotMatchError = providersDoNotMatchError;
// //Bind errors
// export function bindResponseError(input: unknown): SDKExecutionError {
//   return new SDKBindError(
//     `Bind call responded with invalid body: ${JSON.stringify(input)}`,
//     [
//       'OneSdk expects response containing object',
//       'Received object should contain property "provider" of type "ProviderJson"',
//       'Received object should contain property "map_ast" of type "undefined" or "MapDocumentNode"',
//     ],
//     []
//   );
// }
function digestHeaderNotFound(headerName, foundHeaders) {
    return new errors_1.SDKExecutionError("Digest auth failed, unable to extract digest values from response. Header \"" + headerName + "\" not found in response headers.", ["Found headers: " + foundHeaders.join(', ') + "."], [
        'Check API documentation if it specifies challenge header',
        'You can set challenge header in provider.json',
    ]);
}
exports.digestHeaderNotFound = digestHeaderNotFound;
function missingPartOfDigestHeader(headerName, header, part) {
    return new errors_1.SDKExecutionError("Digest auth failed, unable to extract digest values from response. Header \"" + headerName + "\" does not contain \"" + part + "\"", [
        "Header: \"" + headerName + "\" with content: \"" + header + "\" does not contain part specifing: \"" + part + "\"",
    ], []);
}
exports.missingPartOfDigestHeader = missingPartOfDigestHeader;
function unexpectedDigestValue(valueName, value, possibleValues) {
    return new errors_1.SDKExecutionError("Digest auth failed, parameter \"" + valueName + "\" has unexpected value: \"" + value + "\"", [
        "Digest auth failed, parameter \"" + valueName + "\" has unexpected value: \"" + value + "\". Supported values: " + possibleValues.join(', '),
    ], []);
}
exports.unexpectedDigestValue = unexpectedDigestValue;
// Bind errors
function invalidProviderResponseError(error) {
    if (error instanceof ast_1.AssertionError) {
        return new errors_1.SDKBindError('Bind call responded with invalid provider body', error.detailed().split('\n'), ['Received provider should be of type "ProviderJson"']);
    }
    return new errors_1.SDKBindError("Bind call response validation failed with unexpected error: " + JSON.stringify(error), [], []);
}
exports.invalidProviderResponseError = invalidProviderResponseError;
function bindResponseError(_a) {
    var statusCode = _a.statusCode, profileId = _a.profileId, provider = _a.provider, title = _a.title, detail = _a.detail, mapVariant = _a.mapVariant, mapRevision = _a.mapRevision;
    var longLines = [];
    if (detail) {
        longLines.push(detail);
    }
    if (mapVariant) {
        longLines.push("Looking for map variant \"" + mapVariant + "\"");
    }
    if (mapRevision) {
        longLines.push("Looking for map revision \"" + mapRevision + "\"");
    }
    return new errors_1.SDKBindError("Registry responded with status code " + statusCode + (title ? " - " + title + "." : '.'), longLines, [
        provider
            ? "Check if profile \"" + profileId + "\" can be used with provider \"" + provider + "\""
            : "Check if profile \"" + profileId + "\" can be used with selected provider.",
        "If you are using remote profile you can check informations about profile at \"" + new URL(profileId, config_1.Config.instance().superfaceApiUrl).href + "\"",
        "If you are trying to use remote profile check if profile \"" + profileId + "\" is published",
        'If you are using local profile you can use local map and provider to bypass the binding',
    ]);
}
exports.bindResponseError = bindResponseError;
function unknownBindResponseError(_a) {
    var statusCode = _a.statusCode, profileId = _a.profileId, body = _a.body, provider = _a.provider, mapVariant = _a.mapVariant, mapRevision = _a.mapRevision;
    var longLines = [
        provider
            ? "Error occured when binding profile \"" + profileId + "\" with provider \"" + provider + "\""
            : "Error occured when binding profile \"" + profileId + "\" with selected provider",
    ];
    if (mapVariant) {
        longLines.push("Looking for map variant \"" + mapVariant + "\"");
    }
    if (mapRevision) {
        longLines.push("Looking for map revision \"" + mapRevision + "\"");
    }
    return new errors_1.SDKBindError("Registry responded with status code " + statusCode + " and unexpected body " + String(body), longLines, [
        provider
            ? "Check if profile \"" + profileId + "\" can be used with provider \"" + provider + "\""
            : "Check if profile \"" + profileId + "\" can be used with selected provider",
        "If you are using remote profile you can check informations about profile at \"" + new URL(profileId, config_1.Config.instance().superfaceApiUrl).href + "\"",
        "If you are trying to use remote profile check if profile \"" + profileId + "\" is published",
        'If you are using local profile you can use local map and provider to bypass the binding',
    ]);
}
exports.unknownBindResponseError = unknownBindResponseError;
function unknownProviderInfoError(_a) {
    var message = _a.message, provider = _a.provider, body = _a.body, statusCode = _a.statusCode;
    var longLines = [
        message,
        "Error occured when fetching info about provider \"" + provider + "\"",
    ];
    return new errors_1.SDKExecutionError("Registry responded with status code " + statusCode + " and unexpected body " + String(body), longLines, ["Check if provider \"" + provider + "\" is published"]);
}
exports.unknownProviderInfoError = unknownProviderInfoError;
//# sourceMappingURL=errors.helpers.js.map